package compiler

import "core:fmt"
import "core:os"
import "core:path/filepath"
import "core:strconv"
import "core:strings"
import "core:time"

// Import the x64 assembler package
import x64 "./x64"

/*
 * generate_code is the main entry point for code generation
 * It takes the AST and analyzer results and produces output code
 */
generate_code :: proc(ast: ^Node, analyzer: ^Analyzer, output_file: string) {
	if ast == nil {
		fmt.eprintln("Error: Cannot generate code from nil AST")
		return
	}

	if analyzer == nil {
		fmt.eprintln("Error: Cannot generate code without analyzer data")
		return
	}

	// Determine the output file name
	final_output_file := output_file
	if final_output_file == "" {
		// If no output file is specified, use the input file name without extension
		input_file := analyzer.filename
		ext := filepath.ext(input_file)
		if ext != "" {
			// Remove extension and use that as the output file
			final_output_file = input_file[:len(input_file) - len(ext)]
		} else {
			// If there's no extension, just use the input filename
			final_output_file = input_file
		}
	}

	// Start timing for code generation
	gen_start := time.now()

	// Initialize the bytecode buffer
	buffer := x64.ByteBuffer{}

	// Set the buffer as the context's user pointer for assembly functions
	context.user_ptr = &buffer

	// Generate machine code
	generate_assembly(ast, analyzer)

	// Write the generated bytecode to the output file
	err := os.write_entire_file_or_err(final_output_file, buffer.data[:buffer.len])
	if err != nil {
		fmt.eprintf("Error writing to output file '%s': %v\n", final_output_file, err)
	} else {
		fmt.printf("Generated code written to '%s' (%d bytes)\n", final_output_file, buffer.len)
	}

	// Report generation time
	gen_duration := time.diff(gen_start, time.now())
	fmt.printf("Code generation time: %.3fms\n", f64(time.duration_milliseconds(gen_duration)))
}

// Main assembly generation function
generate_assembly :: proc(ast: ^Node, analyzer: ^Analyzer) {
	x64.write_elf()
	// Generate code for the AST
	x64.mov_r64_imm64(.RDI, 0)
	x64.mov_r64_imm64(.RAX, 60)
	x64.syscall()
	// generate_node(ast, analyzer)
}

// Generate code for an AST node
generate_node :: proc(node: ^Node, analyzer: ^Analyzer) {
	if node == nil do return

	#partial switch n in node^ {
	case Scope:
		// Process each statement in the scope
		for i := 0; i < len(n.value); i += 1 {
			generate_node(&n.value[i], analyzer)
		}

	case Pointing:
		// Handle variable definition or assignment
		if n.value != nil {
			generate_node(n.value, analyzer)
			// Result is in RAX
		}

	case Literal:
		// Handle literals (numbers, strings, etc.)
		switch n.kind {
		case .Integer:
			value, parse_ok := strconv.parse_int(n.value, 10)
			if parse_ok {
				x64.mov_r64_imm64(.RAX, u64(value))
			}
		case .Hexadecimal:
		case .Binary:
		case .Float:
		// Floats would need special handling
		case .String:
		// Strings would need special handling
		case .Bool:
			if n.value == "true" {
				x64.mov_r64_imm64(.RAX, 1)
			} else if n.value == "false" {
				x64.mov_r64_imm64(.RAX, 0)
			}
		}

	case Operator:
		// Handle binary operators
		if n.left != nil {
			generate_node(n.left, analyzer)
			x64.push_r64(.RAX) // Save left operand
		}

		if n.right != nil {
			generate_node(n.right, analyzer)
			// Right operand is in RAX

			// Pop left operand into RBX
			x64.pop_r64(.RBX)

			// Perform operation based on operator
			#partial switch n.kind {
			case .Plus:
				x64.add_r64_r64(.RAX, .RBX)
			case .Minus:
				x64.mov_r64_r64(.RCX, .RAX)
				x64.mov_r64_r64(.RAX, .RBX)
				x64.sub_r64_r64(.RAX, .RCX)
			case .Mult:
				x64.imul_r64_r64(.RAX, .RBX)
			case .Div:
				x64.mov_r64_r64(.RCX, .RAX)
				x64.mov_r64_r64(.RAX, .RBX)
				x64.xor_r64_r64(.RDX, .RDX)
				x64.div_r64(.RCX)
			}
		}

	case Identifier:
		// Handle variable references
		// This would need to look up the variable and load its value
		// For now, we'll just set RAX to a dummy value
		x64.mov_r64_imm64(.RAX, 0)

	case Execute:
		// Handle function calls
		if n.value != nil {
			generate_node(n.value, analyzer)
			// Function pointer is in RAX
			x64.call_r64(.RAX)
		}

	case Product:
		// Handle return values
		if n.value != nil {
			generate_node(n.value, analyzer)
			// Return value is in RAX
		}

	case Pattern:
	// Handle pattern matching
	// This would need more complex code generation

	case Branch:
	// Handle conditional branches
	// This would need more complex code generation
	}
}
