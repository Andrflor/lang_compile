`trolol
dwdwk fait du \n multiline whoula`
super 0.22
0xff22
2 1 1
0b101
1..2
2&2
2^2
2%2
2*2
2+2
2-2
2/2
~2
^2
super..plop
Counter -> {
  Change -> {
    u8:value
  }
  -> {
    // Value of type u8 driven by change event default is 0
    u8:value >>- Change -> 0
    // Change resonance handler
    Change -< e {
      // We can use resonance to drive value here
      value -<< e.value
    }
    increment -> {
      // Emiting change event
      >- Change{value+1}
    }
    decrement -> {
      // Emiting change event
      >- Change{value-1}
    }
    // This is the correct Change driven value
    -> value
  }
  // We are using ?? and compile time default constant force to proove properties
  incrementAlwaysIncreases -> {
    u8:prev -> ??
    Counter:count{value -> prev}
    count.increment!
    -> count! = prev + 1
  }
  decrementAlwaysDecreases -> {
    u8:prev -> ??
    Counter:count{value -> prev}
    count.decrement!
    -> count! = prev - 1
  }
  incrementAndDecrementAreComplementaty -> {
    u8:prev -> ??
    Counter:count{value -> prev}
    count.increment!
    count.decrement!
    -> count! = prev
  }
}

Counter:globalCounter
// This is a bind so it's value will reflect globalCounter.value
// Bind can be used as the same as references if they can be resolved to one
// Here there is a computation that prevent to make it a reference
// As such it would be recomputed each time Change is triggered
bool:counterPositive >>= globalCounter.value >= 0
funWithCounter -> {
  globalCounter.decrement!
  globalCounter.increment!
}

funWithCounter! // counterPositive updates to false then to true again

State -> {
  T <- None
  T:initial
  Update -> {
    T:value
  }
  -> {
    T:value >>- Update -> initial
    Update -< e {
      value -<< e.value
    }
    update -> {
      T:value
      >- Update{value}
    }
    -> value
  }
}

DynList -> {
  T -> None
  Update -> {
    T:data
    u64:length
  }
  -> {
    u64:length
    List{T}:value
    length -> // Need to compute initial length
    length >>- Update
    value >>- Update
    Update -< e {
      value -<< e.data
      length -<< e.length
    }
    push -> {
      T:element
      >- Update{{...value element} _length+1}
    }
    -> value
  }
}

State -> {
  T <- None
  T:initial
  Update -> { T:value }
  -> {
    T:value >>- Update -> initial
    Update -< e { value -<< e.value ,}
    update -> { T:value, >- Update{value}}
    -> value
  }
}

RefState -> {
  T <- None
  T:initial
  Update -> { T:value }
  -> {
    T:value >>- Update >>= initial
    Update -< e { value -<< e.value }
    update -> { T:value, >- Update{value}}
    -> value
  }
}

Node -> {
  T <- {}
  T:data
  RefState{{}|Node{T:}:}:next
}

Node:nodeA{0}
Node:nodeB{2 next->RefState{nodeA}:}
nodeA.next.update{nodeB}!

nodeB.next!.next! // nodeA nodeB

DynList{u8}:dynList{value->{1 2 3 4 5}}
dynList.length // 5
dynList.push{6}!
dynList! // {1 2 3 4 5 6}
dynList.length // 6

Logging -> {
  Log -> {
    String:message
  }
  Log -< e {
    -> io.write{e.message}!
  }
}

main -> {
  ...Logging
   Counter:counter
   >- Log{counter!} // 0
   counter.increment!
   >- Log{counter!} // 1
   counter.decrement!
   >- Log{counter!} // 0
}

main!

List -> {
  T -> None
  -> {}
  -> {
    T:
    ...List{T}:
  }
}

Array -> {
  T -> None
  u32:length
  generate -> {
    T -> None
    u32:length
    length=0 ? {
      -> {}
      -> {T: ...generate{T length-1}!}
    }
  }
  -> generate{T length}!
}

NDArray {
  u32:rank <- 0
  T <- None
  List{T}:source >>= {}
  Array{u64 rank}:shape
  Array{i64 rank}:stride
  u64:offset
}


NDArray:array{{2 0 3 4 1} shape->{4 1} stride{1 1}}
