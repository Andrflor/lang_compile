// Refinement type
intPlus -> {
  -> {
    (v) -> 1
    -> v ?! >0
   }!
}

(u8|i8)&>10:x

intPlus:b -> 4
intPlus:c -> 10

Foo -> {
  T -> 0
  -> T%2 ? {
    0 -> // something
    1 -> // something else
  }
}


// Theorem proving trough constraint constant default
RSAIdentity -> {
  PubKey:pub
  PrivKey:priv
  -> {
    String:m -> ??
    -> decrypt{encrypt{m, priv}! pub}! = m ?! true
  }
}

// Compile time effect trigered on anythinhg
compileTimeGet -> !{@http.get}
// Can be used on anything

N -> {
  -> {}
  -> {{} ...N:}

  equal -> {
    N:a
    N:b
    -> a = b
  }

  add -> {
    N:a
    N:b
    -> {...a ...b}
  }

  sub -> {
    N:a
    N:b
    -> a ? {...b ...(r)} ? {
      -> r
      -> b ? {{...a ...(r)} -> {-1 r}
    }
  }

  mult -> {
    N:a
    N:b
    -> a ? {
      {{} ...(r)} -> {...b ...mult{r b}!}
      -> {}
    }
  }
}

Z -> {
  -> N:
  -> {-1 N:}
  equal -> {
    Z:a
    Z:b
    -> a = b
  }
  sym -> {
    Z:z
    -> z ? {
      {-1 N:(n)} -> n
      N: -> Z:{-1 z}
    }
  }
  add -> {
    Z:a
    Z:b
    {a b} ? {
      {N:(a) N:(b)} -> N.add{a b}!
      {N:(a) {-1 N:(b)}} -> N.sub{a b}!
      {{-1 N:(a)} N:(b)} -> N.sub{b a}!
      {{-1 N:(a)} {-1 N:(b)}} -> {-1 N.add{a b}!}
    }

  }
  sub -> {
    Z:a
    Z:b
    -> add{a symetric{b}!}!
  }
  mult -> {
    Z:a
    Z:b
    -> {a b} ? {
      {N:(a) N:(b)} | {{-1 N:(a)} {-1 N:(b)}} -> N.mult{a b}!
      {{-1 N:(a)} N:(b)} | {{N:(a)} {-1 N:(b)}} -> Z:{-1 N.mult{a b}!}
    }
  }
}

Q -> {
  -> Z:
  -> {Z:n (N&~{}):d}
  equal -> {
    Q:a
    Q:b
    -> Z.mult{a.n b.d}! = Z.mult{b.n a.d}!
  }
  inv -> {
    Q:{n?(!={}&!={-1 {}})}:q
    -> q.n ? {
      (N&~{}):(n) -> Q:{q n}
      {-1 (N&~{})}:(n)} -> Q:{{-1 q} n}
    }
  }
  sym -> {
    Q:q
    -> Q:{Z.sym{q.n}! d}
  }
  add -> {
    Q:a
    Q:b
    -> Q:{Z.add{Z.mult{a.n b.d}! Z.mult{b.n a.d}!}! N.mult{a.d b.d}!}
  }
  mult -> {
    Q:a
    Q:b
    -> {Z.mult{a.n b.n}! N.mult{a.d b.d}!}
  }
}


succ -> {
  Nat:nat
  -> {...nat {}}
}


one -> {{}}
two -> {{}{}}

succ{one}! = two // true

add -> {
  Nat:a
  Nat:b
  -> {...a ...b}
}

mult -> {
  Nat:a
  Nat:b
  -> a ? {
    {} -> {}
    {{} ...Nat:(r)} -> {...b ...mult{r b}!}
  }
}

multByOne -> {
  Nat:n -> ??
  -> mult{n {{}}}! = n ?! true
}

addCommutative -> {
  Nat:a -> ??
  Nat:b -> ??
  -> add{a b}! = add{b a}! ?! true
}

Ring {
  T -> {}
  addNeutral -> {}
  add -> {
    T: a
    T: b
    -> {...a ...b}
  }
  mult -> {
    T:a
    T:b
    -> a ? {
      {} -> {}
      {{} ...T:(r)} -> {...b ...mult{r b}!}
    }
  }
  addCommutative -> {
    T:a -> ??
    T:b -> ??
    -> add{a b}! = add{b a}! ?! true
  }
  multByOne -> {
  T:n -> ??
  -> mult{n {{}}}! = n ?! true
  }
}
