// Refinement type
intPlus -> {
  -> {
    (v) -> 1
    -> v ?! >0
   }!
}

(u8|i8)&>10:x

intPlus:b -> 4
intPlus:c -> 10

Foo -> {
  T -> 0
  -> T%2 ? {
    0 -> // something
    1 -> // something else
  }
}


// Theorem proving trough constraint constant default
RSAIdentity -> {
  PubKey:pub
  PrivKey:priv
  -> {
    String:m -> ??
    -> decrypt{encrypt{m, priv}! pub}! = m ?! true
  }
}

// Compile time effect trigered on anythinhg
compileTimeGet -> !{@http.get}
// Can be used on anything

u8 -> {
  -> u8:(i)
  avg -> {
    u8:e
    -> (e+i)/2
  }
}

N -> {
  -> {}
  -> {{} ...N:}

  equal -> {
    N:a
    N:b
    -> a = b
  }

  add -> {
    N:a
    N:b
    -> {...a ...b}
  }

  sub -> {
    N:a
    N:b
    -> a ? {
      {...b ...(r)} -> r
      -> b ? {
        {...a ...(r)} -> {-1 r}
        -> {}
    }
  }

  mult -> {
    N:a
    N:b
    -> a ? {
      {{} ...(r)} -> {...b ...mult{r b}!}
      -> {}
    }
  }
}

Z -> {
  -> N:
  -> {-1 N:}
  equal -> {
    Z:a
    Z:b
    -> a = b
  }
  sym -> {
    Z:z
    -> z ? {
      {-1 N:(n)} -> n
      N: -> Z:{-1 z}
    }
  }
  add -> {
    Z:a
    Z:b
    {a b} ? {
      {N:(a) N:(b)} -> N.add{a b}!
      {N:(a) {-1 N:(b)}} -> N.sub{a b}!
      {{-1 N:(a)} N:(b)} -> N.sub{b a}!
      {{-1 N:(a)} {-1 N:(b)}} -> {-1 N.add{a b}!}
    }

  }
  sub -> {
    Z:a
    Z:b
    -> add{a symetric{b}!}!
  }
  mult -> {
    Z:a
    Z:b
    -> {a b} ? {
      {N:(a) N:(b)} | {{-1 N:(a)} {-1 N:(b)}} -> N.mult{a b}!
      {{-1 N:(a)} N:(b)} | {N:(a) {-1 N:(b)}} -> Z:{-1 N.mult{a b}!}
    }
  }
}

Q -> {
  -> Z:
  -> {Z:n (N&~{}):d}
  equal -> {
    Q:a
    Q:b
    -> Z.mult{a.n b.d}! = Z.mult{b.n a.d}!
  }
  inv -> {
    ?Q:{(n~({}|{-1 {}}))|~({}|{-1 {}})}:q
    -> q.n ? {
      (N&~{}):(n) -> Q:{q n}
      {-1 (N&~{})}:(n)} -> Q:{{-1 q} n}
    }
  }
  sym -> {
    Q:q
    -> Q:{Z.sym{q.n}! d}
  }
  add -> {
    Q:a
    Q:b
    -> Q:{Z.add{Z.mult{a.n b.d}! Z.mult{b.n a.d}!}! N.mult{a.d b.d}!}
  }
  mult -> {
    Q:a
    Q:b
    -> {Z.mult{a.n b.n}! N.mult{a.d b.d}!}
  }
}

succ -> {
  Nat:nat
  -> {...nat {}}
}


one -> {{}}
two -> {{}{}}

succ{one}! = two // true

add -> {
  Nat:a
  Nat:b
  -> {...a ...b}
}

mult -> {
  Nat:a
  Nat:b
  -> a ? {
    {} -> {}
    {{} ...Nat:(r)} -> {...b ...mult{r b}!}
  }
}

multByOne -> {
  Nat:n -> ??
  -> mult{n {{}}}! = n ?! true
}

addCommutative -> {
  Nat:a -> ??
  Nat:b -> ??
  -> add{a b}! = add{b a}! ?! true
}

Ring {
  T -> {}
  addNeutral -> {}
  add -> {
    T: a
    T: b
    -> {...a ...b}
  }
  mult -> {
    T:a
    T:b
    -> a ? {
      {} -> {}
      {{} ...T:(r)} -> {...b ...mult{r b}!}
    }
  }
  addCommutative -> {
    T:a -> ??
    T:b -> ??
    -> add{a b}! = add{b a}! ?! true
  }
  multByOne -> {
  T:n -> ??
  -> mult{n {{}}}! = n ?! true
  }
}

Data -> {
  -> {
    u8:i
    String:name
  }
}

Data -> {
  u8:i
  String:name
}

Data:some

Data:some{i->4}
Data:{i->4}
Data{->Data!{i8:i}}



N -> {
  -> {}
  -> {{} ...N:}
}
NZero -> {}
NStar -> N ~ NZero

Z -> {
  -> N:
  -> {-1 N:}
}
ZZero -> NZero | {-1 NZero}
ZStart -> Z ~ Zero

Q -> {
  -> Z:
  -> {Z:n NStar:d}
}
QZero -> ZZero | ?Q:{ZZero:n}
QStar -> Q ~ QZero

QStar -> Q ~ {{}|{-1 {}}} | ?Q:{n~{{}|{-1 {}}}}

false | true
false & true
i & u

n -> {ZZero:n NStar:d}
ZZero | n


u8:a -> 10
data -> {u8:a u8:b}
data2 -> {
   -> {u8:a u8:b}
}

b ? {
  a -> // b is a
  >a -> //b is superior to a
  a: -> // b is the shape of a
  >a: -> // b is superset of a
  data -> // b is data
  data: -> // b is shape data
  >data: -> // b is superset data
  data2 -> // b is data2
  data2: -> // b is shape of data2
  >data2: -> // b is superset data2
}
