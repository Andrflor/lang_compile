package x64_assembler

// ===== REGISTER DEFINITIONS =====
Register64 :: enum u8 {
    RAX = 0, RCX = 1, RDX = 2, RBX = 3,
    RSP = 4, RBP = 5, RSI = 6, RDI = 7,
    R8  = 8, R9  = 9, R10 = 10, R11 = 11,
    R12 = 12, R13 = 13, R14 = 14, R15 = 15,
}

XMMRegister :: enum u8 {
    XMM0 = 0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7,
    XMM8, XMM9, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15,
    XMM16, XMM17, XMM18, XMM19, XMM20, XMM21, XMM22, XMM23,
    XMM24, XMM25, XMM26, XMM27, XMM28, XMM29, XMM30, XMM31,
}

x87Register :: enum u8 {
    ST0 = 0, ST1, ST2, ST3, ST4, ST5, ST6, ST7
}

// ===== DATA MOVEMENT INSTRUCTIONS =====
// --- General Purpose Register Movement ---
mov_r64_imm64 :: proc(reg: Register64, imm: u64) {}
mov_r64_r64 :: proc(dst: Register64, src: Register64) {}
mov_r64_m64 :: proc(dst: Register64, mem_addr: u64) {}
mov_m64_r64 :: proc(mem_addr: u64, src: Register64) {}
movabs_r64_imm64 :: proc(reg: Register64, imm: u64) {}
xchg_r64_r64 :: proc(dst: Register64, src: Register64) {}

// --- Sign and Zero Extensions ---
movsx_r64_r32 :: proc(dst: Register64, src: Register64) {}
movzx_r64_r32 :: proc(dst: Register64, src: Register64) {}

// --- Byte Order Control ---
movbe_r64_m64 :: proc(dst: Register64, mem_addr: u64) {}
movbe_m64_r64 :: proc(mem_addr: u64, src: Register64) {}
bswap_r64 :: proc(reg: Register64) {}  // Byte swap

// --- Special Registers ---
mov_cr_r64 :: proc(cr: u8, reg: Register64) {}
mov_r64_cr :: proc(reg: Register64, cr: u8) {}
mov_cr0_r64 :: proc(reg: Register64) {}
mov_cr2_r64 :: proc(reg: Register64) {}
mov_cr3_r64 :: proc(reg: Register64) {}
mov_cr4_r64 :: proc(reg: Register64) {}

// --- Debug Registers ---
mov_dr0_r64 :: proc(reg: Register64) {}
mov_dr1_r64 :: proc(reg: Register64) {}
mov_dr2_r64 :: proc(reg: Register64) {}
mov_dr3_r64 :: proc(reg: Register64) {}
mov_dr6_r64 :: proc(reg: Register64) {}
mov_dr7_r64 :: proc(reg: Register64) {}

// --- Address Manipulation ---
lea_r64_m64 :: proc(dst: Register64, mem_addr: u64) {}
lea_r64_m :: proc(dst: Register64, mem: u64) {}

// ===== ARITHMETIC INSTRUCTIONS =====
// --- Basic Arithmetic ---
add_r64_imm32 :: proc(reg: Register64, imm: u32) {}
add_r64_r64 :: proc(dst: Register64, src: Register64) {}
sub_r64_imm32 :: proc(reg: Register64, imm: u32) {}
sub_r64_r64 :: proc(dst: Register64, src: Register64) {}
inc_r64 :: proc(reg: Register64) {}
dec_r64 :: proc(reg: Register64) {}
neg_r64 :: proc(reg: Register64) {}

// --- Advanced Arithmetic ---
adc_r64_r64 :: proc(dst: Register64, src: Register64) {}  // Add with carry
sbb_r64_r64 :: proc(dst: Register64, src: Register64) {}  // Subtract with borrow
xadd_r64_r64 :: proc(dst: Register64, src: Register64) {} // Exchange and add

// --- Multiplication and Division ---
mul_r64 :: proc(reg: Register64) {}     // Unsigned multiply
imul_r64_r64 :: proc(dst: Register64, src: Register64) {}  // Signed multiply
imul_r64_r64_imm32 :: proc(dst: Register64, src: Register64, imm: u32) {}
imul_r64_imm32 :: proc(reg: Register64, imm: u32) {}
div_r64 :: proc(reg: Register64) {}     // Unsigned divide
idiv_r64 :: proc(reg: Register64) {}    // Signed divide

// ===== BITWISE INSTRUCTIONS =====
// --- Basic Bitwise Operations ---
and_r64_r64 :: proc(dst: Register64, src: Register64) {}
or_r64_r64 :: proc(dst: Register64, src: Register64) {}
xor_r64_r64 :: proc(dst: Register64, src: Register64) {}
not_r64 :: proc(reg: Register64) {}

// --- Shifts and Rotates ---
shl_r64_imm8 :: proc(reg: Register64, imm: u8) {
    assert(imm <= 63, "Shift amount must be 0-63")
}
shr_r64_imm8 :: proc(reg: Register64, imm: u8) {
    assert(imm <= 63, "Shift amount must be 0-63")
}
rol_r64_imm8 :: proc(reg: Register64, imm: u8) {
    assert(imm <= 63, "Rotate amount must be 0-63")
}
ror_r64_imm8 :: proc(reg: Register64, imm: u8) {
    assert(imm <= 63, "Rotate amount must be 0-63")
}
shld_r64_r64_imm8 :: proc(dst: Register64, src: Register64, imm: u8) {}
shrd_r64_r64_imm8 :: proc(dst: Register64, src: Register64, imm: u8) {}

// --- Bit Manipulation ---
bt_r64_r64 :: proc(reg: Register64, bit_index: Register64) {}   // Bit test
bts_r64_r64 :: proc(reg: Register64, bit_index: Register64) {}  // Bit test and set
btr_r64_r64 :: proc(reg: Register64, bit_index: Register64) {}  // Bit test and reset
btc_r64_r64 :: proc(reg: Register64, bit_index: Register64) {}  // Bit test and complement
bsf_r64_r64 :: proc(dst: Register64, src: Register64) {}        // Bit scan forward
bsr_r64_r64 :: proc(dst: Register64, src: Register64) {}        // Bit scan reverse
popcnt_r64_r64 :: proc(dst: Register64, src: Register64) {}     // Population count
lzcnt_r64_r64 :: proc(dst: Register64, src: Register64) {}      // Leading zero count
tzcnt_r64_r64 :: proc(dst: Register64, src: Register64) {}      // Trailing zero count
pext_r64_r64_r64 :: proc(dst: Register64, src1: Register64, src2: Register64) {}  // Parallel bits extract
pdep_r64_r64_r64 :: proc(dst: Register64, src1: Register64, src2: Register64) {}  // Parallel bits deposit

// ===== COMPARISON INSTRUCTIONS =====
cmp_r64_r64 :: proc(reg1: Register64, reg2: Register64) {}
cmp_r64_imm32 :: proc(reg: Register64, imm: u32) {}
test_r64_r64 :: proc(reg1: Register64, reg2: Register64) {}
test_r64_imm32 :: proc(reg: Register64, imm: u32) {}

// --- Conditional Moves ---
cmove_r64_r64 :: proc(dst: Register64, src: Register64) {}    // Move if equal
cmovne_r64_r64 :: proc(dst: Register64, src: Register64) {}   // Move if not equal
cmova_r64_r64 :: proc(dst: Register64, src: Register64) {}    // Move if above
cmovae_r64_r64 :: proc(dst: Register64, src: Register64) {}   // Move if above or equal
cmovb_r64_r64 :: proc(dst: Register64, src: Register64) {}    // Move if below
cmovbe_r64_r64 :: proc(dst: Register64, src: Register64) {}   // Move if below or equal

// ===== CONTROL FLOW INSTRUCTIONS =====
// --- Unconditional Jumps & Calls ---
jmp_rel32 :: proc(offset: i32) {}
jmp_r64 :: proc(reg: Register64) {}
jmp_m64 :: proc(mem_addr: u64) {}
call_rel32 :: proc(offset: i32) {}
call_r64 :: proc(reg: Register64) {}
call_m64 :: proc(mem_addr: u64) {}
ret :: proc(buf: ^X64_Buffer) {}

// --- Conditional Jumps ---
je_rel32 :: proc(offset: i32) {}     // Jump if equal
jne_rel32 :: proc(offset: i32) {}    // Jump if not equal
jg_rel32 :: proc(offset: i32) {}     // Jump if greater
jl_rel32 :: proc(offset: i32) {}     // Jump if less
jge_rel32 :: proc(offset: i32) {}    // Jump if greater or equal
jle_rel32 :: proc(offset: i32) {}    // Jump if less or equal
ja_rel32 :: proc(offset: i32) {}     // Jump if above
jae_rel32 :: proc(offset: i32) {}    // Jump if above or equal
jb_rel32 :: proc(offset: i32) {}     // Jump if below
jbe_rel32 :: proc(offset: i32) {}    // Jump if below or equal

// --- Loop Control ---
loop_rel8 :: proc(offset: i8) {}     // Decrement ECX/RCX; jump if not zero
loope_rel8 :: proc(offset: i8) {}    // Loop while equal
loopne_rel8 :: proc(offset: i8) {}   // Loop while not equal
jecxz_rel8 :: proc(offset: i8) {}    // Jump if ECX/RCX is zero

// --- Miscellaneous Control Flow ---
setcc_r8 :: proc(dst: u8) {}
endbr64 :: proc(buf: ^X64_Buffer) {} // End branch (for Control-flow Enforcement Technology)

// ===== STACK MANIPULATION =====
push_r64 :: proc(reg: Register64) {}
pop_r64 :: proc(reg: Register64) {}
pushfq :: proc(buf: ^X64_Buffer) {}  // Push RFLAGS
popfq :: proc(buf: ^X64_Buffer) {}   // Pop RFLAGS

// ===== SIMD INSTRUCTIONS =====
// --- SSE/AVX Data Movement ---
movd_xmm_r64 :: proc(xmm: XMMRegister, reg: Register64) {}
movd_r64_xmm :: proc(reg: Register64, xmm: XMMRegister) {}
movups_xmm_m128 :: proc(dst: XMMRegister, mem: u64) {}
movdqu_xmm_m128 :: proc(dst: XMMRegister, mem: u64) {}

// --- SSE/AVX Arithmetic ---
addps_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}
mulps_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}
divps_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}
sqrtps_xmm :: proc(xmm: XMMRegister) {}

// --- SSE/AVX Comparison ---
cmpps_xmm_xmm_imm8 :: proc(dst: XMMRegister, src: XMMRegister, imm: u8) {}
cmpeqps_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}
cmpneqps_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}

// --- AVX FMA (Fused Multiply-Add) ---
vfmadd132ps_xmm_xmm_xmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vfmadd213ps_xmm_xmm_xmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vfmadd231ps_xmm_xmm_xmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}

// --- AVX Advanced Operations ---
vaddps_ymm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vmulps_ymm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vdivps_ymm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vblendps_ymm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister, imm: u8) {}
vpand_ymm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vpor_ymm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vpxor_ymm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vpternlogd_ymm_ymm_ymm_imm8 :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister, imm: u8) {}
vextracti128_ymm_ymm_imm8 :: proc(dst: XMMRegister, src: XMMRegister, imm: u8) {}

// --- SIMD Integer Operations ---
pavgb_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}
pavgb_ymm_ymm :: proc(dst: XMMRegister, src: XMMRegister) {}
pmaddwd_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}
pmulhuw_xmm_xmm :: proc(dst: XMMRegister, src: XMMRegister) {}

// --- AVX-512 Operations ---
vaddpd_zmm_zmm_zmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vsubpd_zmm_zmm_zmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vmulpd_zmm_zmm_zmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vdivpd_zmm_zmm_zmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vgatherdps_xmm :: proc(dst: XMMRegister) {}
vscatterdps_xmm :: proc(dst: XMMRegister) {}
kmovq_k_k :: proc(dst: u8, src: u8) {}
vpxordq_zmm_zmm_zmm :: proc(dst: XMMRegister, src1: XMMRegister, src2: XMMRegister) {}
vpscatterdd_ymm_m :: proc(src: XMMRegister, mem: u64) {}
vpscatterdq_ymm_m :: proc(src: XMMRegister, mem: u64) {}
vpscatterqd_ymm_m :: proc(src: XMMRegister, mem: u64) {}
vpcompressd_ymm_ymm :: proc(dst: XMMRegister, src: XMMRegister) {}
vpcompressq_ymm_ymm :: proc(dst: XMMRegister, src: XMMRegister) {}

// ===== CRYPTOGRAPHY INSTRUCTIONS =====
aesenc :: proc(dst: XMMRegister, src: XMMRegister) {}        // AES encryption round
aesdec :: proc(dst: XMMRegister, src: XMMRegister) {}        // AES decryption round
pclmulqdq :: proc(dst: XMMRegister, src: XMMRegister, imm: u8) {}  // Carryless multiplication
crc32_r64_r64 :: proc(dst: Register64, src: Register64) {}  // CRC-32 computation

// ===== X87 FLOATING POINT INSTRUCTIONS =====
fadd_st0_st :: proc(src: x87Register) {}       // Add
fsub_st0_st :: proc(src: x87Register) {}       // Subtract
fmul_st0_st :: proc(src: x87Register) {}       // Multiply
fdiv_st0_st :: proc(src: x87Register) {}       // Divide
fcom_st :: proc(src: x87Register) {}           // Compare floating point
fcomp_st :: proc(src: x87Register) {}          // Compare floating point and pop
fucom_st :: proc(src: x87Register) {}          // Unordered compare floating point
fucomp_st :: proc(src: x87Register) {}         // Unordered compare floating point and pop
fldcw :: proc(mem: u64) {}                     // Load x87 FPU control word
fstcw :: proc(mem: u64) {}                     // Store x87 FPU control word
fnstcw :: proc(mem: u64) {}                    // Store x87 FPU control word without checking exceptions
fninit :: proc(buf: ^X64_Buffer) {}            // Initialize x87 FPU
fwait :: proc(buf: ^X64_Buffer) {}             // Wait for x87 FPU to complete current instruction

// ===== MEMORY AND STRING OPERATIONS =====
movs_m64_m64 :: proc(buf: ^X64_Buffer) {}      // Move string
stos_m64 :: proc(buf: ^X64_Buffer) {}          // Store string
cmps_m64_m64 :: proc(buf: ^X64_Buffer) {}      // Compare string
rep_movs :: proc(buf: ^X64_Buffer) {}          // Repeat move string
rep_stos :: proc(buf: ^X64_Buffer) {}          // Repeat store string
rep_cmps :: proc(buf: ^X64_Buffer) {}          // Repeat compare string

// ===== SYSTEM INSTRUCTIONS =====
// --- Interrupts and System Calls ---
syscall :: proc(buf: ^X64_Buffer) {}           // Fast system call
sysret :: proc(buf: ^X64_Buffer) {}            // Return from system call
int_imm8 :: proc(imm: u8) {}                   // Generate software interrupt
int3 :: proc(buf: ^X64_Buffer) {}              // Breakpoint
into :: proc(buf: ^X64_Buffer) {}              // Interrupt on overflow
iret :: proc(buf: ^X64_Buffer) {}              // Interrupt return

// --- Processor Control ---
cpuid :: proc(buf: ^X64_Buffer) {}             // CPU identification
rdtsc :: proc(buf: ^X64_Buffer) {}             // Read time-stamp counter
rdtscp :: proc(buf: ^X64_Buffer) {}            // Read time-stamp counter and processor ID
rdmsr :: proc(buf: ^X64_Buffer) {}             // Read model-specific register
wrmsr :: proc(buf: ^X64_Buffer) {}             // Write model-specific register
rdpmc :: proc(buf: ^X64_Buffer) {}             // Read performance-monitoring counter
hlt :: proc(buf: ^X64_Buffer) {}               // Halt processor

// --- Process & Memory Management ---
swapgs :: proc(buf: ^X64_Buffer) {}            // Swap GS base register
wrpkru :: proc(buf: ^X64_Buffer) {}            // Write PKRU register
rdpkru :: proc(buf: ^X64_Buffer) {}            // Read PKRU register
clac :: proc(buf: ^X64_Buffer) {}              // Clear AC flag (prevents SMAP violations)
stac :: proc(buf: ^X64_Buffer) {}              // Set AC flag (allows supervisor mode access)
ud2 :: proc(buf: ^X64_Buffer) {}               // Undefined instruction (for debugging)

// --- Virtualization Instructions ---
vmcall :: proc(buf: ^X64_Buffer) {}            // VMX guest system call
vmlaunch :: proc(buf: ^X64_Buffer) {}          // Launch VMX non-root operation
vmresume :: proc(buf: ^X64_Buffer) {}          // Resume VMX non-root operation
vmxoff :: proc(buf: ^X64_Buffer) {}            // Exit VMX non-root operation

// ===== ATOMIC OPERATIONS =====
lock_xadd_r64_r64 :: proc(dst: Register64, src: Register64) {}      // Locked exchange and add
lock_cmpxchg_r64_r64 :: proc(dst: Register64, src: Register64) {}   // Locked compare and exchange
lock_inc_r64 :: proc(reg: Register64) {}                            // Locked increment
lock_dec_r64 :: proc(reg: Register64) {}                            // Locked decrement
lock_xchg_r64_r64 :: proc(dst: Register64, src: Register64) {}      // Locked exchange
atomic_load_r64 :: proc(dst: Register64, src: u64) {}               // Atomic load
atomic_store_r64 :: proc(dst: u64, src: Register64) {}              // Atomic store

// ===== TRANSACTIONAL MEMORY INSTRUCTIONS =====
xbegin :: proc(offset: i32) {}                 // Begin transaction
xend :: proc(buf: ^X64_Buffer) {}              // End transaction
xabort :: proc(imm: u8) {}                     // Abort transaction
xtest :: proc(buf: ^X64_Buffer) {}             // Test if executing in a transaction

// ===== RANDOM NUMBER GENERATION =====
rdrand_r64 :: proc(reg: Register64) {}         // Read random number
rdseed_r64 :: proc(reg: Register64) {}         // Read random seed

// ===== PREFETCH INSTRUCTIONS =====
prefetcht0 :: proc(mem: u64) {}                // Prefetch to all cache levels
prefetcht1 :: proc(mem: u64) {}                // Prefetch to L2 cache
prefetcht2 :: proc(mem: u64) {}                // Prefetch to L3 cache
prefetchnta :: proc(mem: u64) {}               // Prefetch with minimal cache pollution

// ===== MEMORY MANAGEMENT AND OPTIMIZATION =====
clflush_m64 :: proc(mem: u64) {}               // Flush cache line
clflushopt_m64 :: proc(mem: u64) {}            // Optimized flush cache line
clwb_m64 :: proc(mem: u64) {}                  // Cache line write back
bound_r64_m128 :: proc(reg: Register64, mem: u64) {}  // Check array bounds

// ===== POWER MANAGEMENT =====
monitor_r64_r64_r64 :: proc(reg1: Register64, reg2: Register64, reg3: Register64) {}  // Set up monitor address
mwait_r64_r64 :: proc(reg1: Register64, reg2: Register64) {}  // Monitor wait

// ===== MEMORY FENCES =====
mfence :: proc(buf: ^X64_Buffer) {}            // Memory fence
lfence :: proc(buf: ^X64_Buffer) {}            // Load fence
sfence :: proc(buf: ^X64_Buffer) {}            // Store fence

// ===== PERFORMANCE MONITORING =====
perfmon_instructions :: proc(buf: ^X64_Buffer) {}  // Placeholder for various performance monitoring instructions
