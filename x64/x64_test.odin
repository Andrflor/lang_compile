///////////////////////////////////////////////////////////////////////////////
//
// x86-64 Assembly Instruction Set Tests
//
// This file contains unit tests for verifying the correctness of x86-64
// assembly instruction encoding.
//
// Author: Florian Andrieu <andrieu.florian@mail.com>
///////////////////////////////////////////////////////////////////////////////
package x64_assembler

import "core:fmt"
import "core:log"
import "core:testing"

// ==================================
// TESTING UTILITIES
// ==================================

// Callback type for executing test cases
VoidCallback :: proc()

// Compares generated bytecode with expected output
// Logs mismatches and marks test as failed if bytes differ
compare_bytecode :: proc(t: ^testing.T, desc: string, expected: []u8, writer: VoidCallback) {
	// Execute the instruction writer to generate bytecode
	writer()

	// Validate length
	if len(expected) != _buffer.len {
		log.info(
			desc,
			": Length mismatch. Expected",
			expected,
			"bytes, got",
			_buffer.data[:_buffer.len],
			"bytes.",
		)
		resetBuffer()
		testing.fail(t)
		return
	}

	// Validate byte content
	for i in 0 ..< len(expected) {
		if expected[i] != _buffer.data[i] {
			log.infof(
				"%s: Byte mismatch at position %d. Expected 0x%02X, got 0x%02X.\n",
				desc,
				i,
				expected[i],
				_buffer.data[i],
			)
			resetBuffer()
			testing.fail(t)
			return
		}
	}

	// Reset buffer for next test case
	resetBuffer()
}

// ==================================
// X86-64 MOV INSTRUCTION TESTS
// ==================================

// --------------------------------
// Basic Register-Immediate Tests
// --------------------------------
@(test)
test_mov_r64_imm64_basic :: proc(t: ^testing.T) {
	// Test basic immediate to register moves

	// RAX with large immediate
	compare_bytecode(
		t,
		"mov rax, 0x123456789ABCDEF0",
		asm_to_bytes("mov rax, 0x123456789ABCDEF0"),
		proc() {mov_r64_imm64(Register64.RAX, 0x123456789ABCDEF0)},
	)

	// RBX with large positive value
	compare_bytecode(
		t,
		"mov rbx, 0x7FFFFFFFFFFFFFFF",
		asm_to_bytes("mov rbx, 0x7FFFFFFFFFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RBX, 0x7FFFFFFFFFFFFFFF)},
	)

	// Small values
	compare_bytecode(
		t,
		"mov r8, 0x1",
		asm_to_bytes("mov r8, 0x1"),
		proc() {mov_r64_imm64(Register64.R8, 0x1)},
	)

	compare_bytecode(
		t,
		"mov rsp, 0x0",
		asm_to_bytes("mov rsp, 0x0"),
		proc() {mov_r64_imm64(Register64.RSP, 0x0)},
	)

	compare_bytecode(
		t,
		"mov rdi, 0x42",
		asm_to_bytes("mov rdi, 0x42"),
		proc() {mov_r64_imm64(Register64.RDI, 0x42)},
	)

	// 32-bit value on extended register
	compare_bytecode(
		t,
		"mov r15, 0x7FFFFFFF",
		asm_to_bytes("mov r15, 0x7FFFFFFF"),
		proc() {mov_r64_imm64(Register64.R15, 0x7FFFFFFF)},
	)
}

// --------------------------------
// Edge Cases for Immediate Values
// --------------------------------
@(test)
test_mov_r64_imm64_edge_cases :: proc(t: ^testing.T) {
	// Test boundary values and edge cases for immediate to register moves

	// 32-bit boundary values
	compare_bytecode(
		t,
		"mov rax, 0xFFFFFFFF", // 32-bit all ones
		asm_to_bytes("mov rax, 0xFFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RAX, 0xFFFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov r9, 0x7FFFFFFF", // Maximum positive 32-bit signed integer
		asm_to_bytes("mov r9, 0x7FFFFFFF"),
		proc() {mov_r64_imm64(Register64.R9, 0x7FFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov r10, 0x80000000", // Minimum negative 32-bit signed integer
		asm_to_bytes("mov r10, 0x80000000"),
		proc() {mov_r64_imm64(Register64.R10, 0x80000000)},
	)

	// Values that can't be represented as sign-extended 32-bit
	compare_bytecode(
		t,
		"mov rbx, 0x80000000", // Just above 32-bit positive range
		asm_to_bytes("mov rbx, 0x80000000"),
		proc() {mov_r64_imm64(Register64.RBX, 0x80000000)},
	)

	compare_bytecode(
		t,
		"mov rcx, 0xFFFFFFFF7FFFFFFF", // Just below 32-bit negative range
		asm_to_bytes("mov rcx, 0xFFFFFFFF7FFFFFFF"),
		proc() {mov_r64_imm64(Register64.RCX, 0xFFFFFFFF7FFFFFFF)},
	)

	// Interesting bit patterns
	compare_bytecode(
		t,
		"mov rdx, 0xFFFFFFFF00000000", // Upper 32 bits all ones, lower 32 bits zeros
		asm_to_bytes("mov rdx, 0xFFFFFFFF00000000"),
		proc() {mov_r64_imm64(Register64.RDX, 0xFFFFFFFF00000000)},
	)

	compare_bytecode(
		t,
		"mov rsi, 0x00000000FFFFFFFF", // Upper 32 bits zeros, lower 32 bits all ones
		asm_to_bytes("mov rsi, 0x00000000FFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RSI, 0x00000000FFFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov rdi, 0xFFFFFFFFFFFFFFFF", // Maximum 64-bit unsigned value
		asm_to_bytes("mov rdi, 0xFFFFFFFFFFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RDI, 0xFFFFFFFFFFFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov r8, 0xAAAAAAAAAAAAAAAA", // Alternating bit pattern
		asm_to_bytes("mov r8, 0xAAAAAAAAAAAAAAAA"),
		proc() {mov_r64_imm64(Register64.R8, 0xAAAAAAAAAAAAAAAA)},
	)
}

// --------------------------------
// Register-to-Register Tests
// --------------------------------
@(test)
test_mov_r64_r64_basic :: proc(t: ^testing.T) {
	// Test basic register to register moves

	// Standard registers
	compare_bytecode(
		t,
		"mov rax, rcx",
		asm_to_bytes("mov rax, rcx"),
		proc() {mov_r64_r64(Register64.RAX, Register64.RCX)},
	)

	// Tests with extended registers
	compare_bytecode(
		t,
		"mov rdx, r8",
		asm_to_bytes("mov rdx, r8"),
		proc() {mov_r64_r64(Register64.RDX, Register64.R8)},
	)

	compare_bytecode(
		t,
		"mov r9, rbx",
		asm_to_bytes("mov r9, rbx"),
		proc() {mov_r64_r64(Register64.R9, Register64.RBX)},
	)

	compare_bytecode(
		t,
		"mov r10, r11",
		asm_to_bytes("mov r10, r11"),
		proc() {mov_r64_r64(Register64.R10, Register64.R11)},
	)
}

@(test)
test_mov_r64_r64_special_registers :: proc(t: ^testing.T) {
	// Test specific cases with RSP, RBP, and other special encodings

	// Same register moves
	compare_bytecode(
		t,
		"mov rax, rax",
		asm_to_bytes("mov rax, rax"),
		proc() {mov_r64_r64(Register64.RAX, Register64.RAX)},
	)

	// RSP as source
	compare_bytecode(
		t,
		"mov rbx, rsp",
		asm_to_bytes("mov rbx, rsp"),
		proc() {mov_r64_r64(Register64.RBX, Register64.RSP)},
	)

	// RSP as destination
	compare_bytecode(
		t,
		"mov rsp, rbx",
		asm_to_bytes("mov rsp, rbx"),
		proc() {mov_r64_r64(Register64.RSP, Register64.RBX)},
	)

	// RBP as source
	compare_bytecode(
		t,
		"mov rcx, rbp",
		asm_to_bytes("mov rcx, rbp"),
		proc() {mov_r64_r64(Register64.RCX, Register64.RBP)},
	)

	// RBP as destination
	compare_bytecode(
		t,
		"mov rbp, rcx",
		asm_to_bytes("mov rbp, rcx"),
		proc() {mov_r64_r64(Register64.RBP, Register64.RCX)},
	)
}

@(test)
test_mov_r64_r64_extended_registers :: proc(t: ^testing.T) {
	// Test combinations with extended registers

	// Extended registers as both source and destination
	compare_bytecode(
		t,
		"mov r12, r13",
		asm_to_bytes("mov r12, r13"),
		proc() {mov_r64_r64(Register64.R12, Register64.R13)},
	)

	// Extended register to standard register
	compare_bytecode(
		t,
		"mov rax, r15",
		asm_to_bytes("mov rax, r15"),
		proc() {mov_r64_r64(Register64.RAX, Register64.R15)},
	)

	// Special and extended register combinations
	compare_bytecode(
		t,
		"mov rsp, r14", // RSP as destination and extended register as source
		asm_to_bytes("mov rsp, r14"),
		proc() {mov_r64_r64(Register64.RSP, Register64.R14)},
	)

	compare_bytecode(
		t,
		"mov r8, rsp", // Extended register as destination and RSP as source
		asm_to_bytes("mov r8, rsp"),
		proc() {mov_r64_r64(Register64.R8, Register64.RSP)},
	)
}

// --------------------------------
// Memory Operations Tests
// --------------------------------
@(test)
test_mov_r64_m64_basic :: proc(t: ^testing.T) {
	// Test memory-to-register operations
	// Standard registers with memory
	compare_bytecode(
		t,
		"mov rax, [0x1000]",
		asm_to_bytes("mov rax, qword ptr [rip+0x1000]"),
		proc() {
			addr: MemoryAddress = 0x1000
			mov_r64_m64(Register64.RAX, addr)
		},
	)
	// Extended registers with memory
	compare_bytecode(
		t,
		"mov r8, [0x7FFF]",
		asm_to_bytes("mov r8, qword ptr [rip+0x7FFF]"),
		proc() {
			addr: MemoryAddress = 0x7FFF
			mov_r64_m64(Register64.R8, addr)
		},
	)
	// Special registers with memory
	compare_bytecode(
		t,
		"mov rsp, [0x8000]",
		asm_to_bytes("mov rsp, qword ptr [rip+0x8000]"),
		proc() {
			addr: MemoryAddress = 0x8000
			mov_r64_m64(Register64.RSP, addr)
		},
	)
}

@(test)
test_mov_r64_m64_address_variations :: proc(t: ^testing.T) {
	// Test memory-to-register operations with different address patterns
	// Small offset
	compare_bytecode(
		t,
		"mov rax, [0xFFF]",
		asm_to_bytes("mov rax, qword ptr [rip+0xFFF]"),
		proc() {
			addr: MemoryAddress = 0xFFF
			mov_r64_m64(Register64.RAX, addr)
		},
	)
	// Typical offset
	compare_bytecode(
		t,
		"mov rbx, [0x7FFF]",
		asm_to_bytes("mov rbx, qword ptr [rip+0x7FFF]"),
		proc() {
			addr: MemoryAddress = 0x7FFF
			mov_r64_m64(Register64.RBX, addr)
		},
	)
	// Larger offset
	compare_bytecode(
		t,
		"mov rcx, [0x12345]",
		asm_to_bytes("mov rcx, qword ptr [rip+0x12345]"),
		proc() {
			addr: MemoryAddress = 0x12345
			mov_r64_m64(Register64.RCX, addr)
		},
	)
	// Page boundary offset
	compare_bytecode(
		t,
		"mov rdx, [0x1000]",
		asm_to_bytes("mov rdx, qword ptr [rip+0x1000]"),
		proc() {
			addr: MemoryAddress = 0x1000
			mov_r64_m64(Register64.RDX, addr)
		},
	)
	// Special encoding register
	compare_bytecode(
		t,
		"mov r12, [0x1234]",
		asm_to_bytes("mov r12, qword ptr [rip+0x1234]"),
		proc() {
			addr: MemoryAddress = 0x1234
			mov_r64_m64(Register64.R12, addr)
		},
	)
}

@(test)
test_mov_m64_r64_basic :: proc(t: ^testing.T) {
	// Test register-to-memory operations
	// Standard registers with memory
	compare_bytecode(
		t,
		"mov [0x1000], rax",
		asm_to_bytes("mov qword ptr [rip+0x1000], rax"),
		proc() {
			addr: MemoryAddress = 0x1000
			mov_m64_r64(addr, Register64.RAX)
		},
	)
	// Extended registers with memory
	compare_bytecode(
		t,
		"mov [0x7FFF], r8",
		asm_to_bytes("mov qword ptr [rip+0x7FFF], r8"),
		proc() {
			addr: MemoryAddress = 0x7FFF
			mov_m64_r64(addr, Register64.R8)
		},
	)
	// Special registers with memory
	compare_bytecode(
		t,
		"mov [0x8000], rsp",
		asm_to_bytes("mov qword ptr [rip+0x8000], rsp"),
		proc() {
			addr: MemoryAddress = 0x8000
			mov_m64_r64(addr, Register64.RSP)
		},
	)
}

@(test)
test_mov_m64_r64_address_variations :: proc(t: ^testing.T) {
	// Test register-to-memory operations with different address patterns
	// Small offset
	compare_bytecode(
		t,
		"mov [0xFFF], rax",
		asm_to_bytes("mov qword ptr [rip+0xFFF], rax"),
		proc() {
			addr: MemoryAddress = 0xFFF
			mov_m64_r64(addr, Register64.RAX)
		},
	)
	// Typical offset
	compare_bytecode(
		t,
		"mov [0x7FFF], rbx",
		asm_to_bytes("mov qword ptr [rip+0x7FFF], rbx"),
		proc() {
			addr: MemoryAddress = 0x7FFF
			mov_m64_r64(addr, Register64.RBX)
		},
	)
	// Larger offset
	compare_bytecode(
		t,
		"mov [0x12345], rcx",
		asm_to_bytes("mov qword ptr [rip+0x12345], rcx"),
		proc() {
			addr: MemoryAddress = 0x12345
			mov_m64_r64(addr, Register64.RCX)
		},
	)
	// Page boundary offset
	compare_bytecode(
		t,
		"mov [0x1000], rdx",
		asm_to_bytes("mov qword ptr [rip+0x1000], rdx"),
		proc() {
			addr: MemoryAddress = 0x1000
			mov_m64_r64(addr, Register64.RDX)
		},
	)
	// Special encoding register
	compare_bytecode(
		t,
		"mov [0x1234], r12",
		asm_to_bytes("mov qword ptr [rip+0x1234], r12"),
		proc() {
			addr: MemoryAddress = 0x1234
			mov_m64_r64(addr, Register64.R12)
		},
	)
}

@(test)
test_mov_with_comprehensive_addressing :: proc(t: ^testing.T) {
	// 1. Simple register indirect addressing
	compare_bytecode(t, "mov rax, [rbx]", asm_to_bytes("mov rax, qword ptr [rbx]"), proc() {
		base: Maybe(Register64) = Register64.RBX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 2. Register + 8-bit displacement
	compare_bytecode(
		t,
		"mov rcx, [rdx+0x7F]",
		asm_to_bytes("mov rcx, qword ptr [rdx+0x7F]"),
		proc() {
			base: Maybe(Register64) = Register64.RDX
			disp: Maybe(i32) = 0x7F
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RCX, addr)
		},
	)

	// 3. Register + 32-bit displacement
	compare_bytecode(
		t,
		"mov r8, [rdi+0x12345678]",
		asm_to_bytes("mov r8, qword ptr [rdi+0x12345678]"),
		proc() {
			base: Maybe(Register64) = Register64.RDI
			disp: Maybe(i32) = 0x12345678
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R8, addr)
		},
	)

	// 4. SIB - Base + Index
	compare_bytecode(t, "mov r9, [rax+rcx]", asm_to_bytes("mov r9, qword ptr [rax+rcx]"), proc() {
		base: Maybe(Register64) = Register64.RAX
		index: Maybe(Register64) = Register64.RCX
		scale: Maybe(u8) = 1
		components := AddressComponents {
			base  = base,
			index = index,
			scale = scale,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.R9, addr)
	})

	// 5. SIB - Base + Index*2
	compare_bytecode(
		t,
		"mov r10, [rbx+rdx*2]",
		asm_to_bytes("mov r10, qword ptr [rbx+rdx*2]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			index: Maybe(Register64) = Register64.RDX
			scale: Maybe(u8) = 2
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R10, addr)
		},
	)

	// 6. SIB - Base + Index*4
	compare_bytecode(
		t,
		"mov r11, [rcx+r8*4]",
		asm_to_bytes("mov r11, qword ptr [rcx+r8*4]"),
		proc() {
			base: Maybe(Register64) = Register64.RCX
			index: Maybe(Register64) = Register64.R8
			scale: Maybe(u8) = 4
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R11, addr)
		},
	)

	// 7. SIB - Base + Index*8
	compare_bytecode(
		t,
		"mov r12, [rdx+r9*8]",
		asm_to_bytes("mov r12, qword ptr [rdx+r9*8]"),
		proc() {
			base: Maybe(Register64) = Register64.RDX
			index: Maybe(Register64) = Register64.R9
			scale: Maybe(u8) = 8
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R12, addr)
		},
	)

	// 8. SIB - Base + Index + Displacement
	compare_bytecode(
		t,
		"mov r13, [rsi+rdi+0x12]",
		asm_to_bytes("mov r13, qword ptr [rsi+rdi+0x12]"),
		proc() {
			base: Maybe(Register64) = Register64.RSI
			index: Maybe(Register64) = Register64.RDI
			scale: Maybe(u8) = 1
			disp: Maybe(i32) = 0x12
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R13, addr)
		},
	)

	// 9. SIB - Base + Index*4 + Displacement
	compare_bytecode(
		t,
		"mov r14, [rbp+r10*4+0x1234]",
		asm_to_bytes("mov r14, qword ptr [rbp+r10*4+0x1234]"),
		proc() {
			base: Maybe(Register64) = Register64.RBP
			index: Maybe(Register64) = Register64.R10
			scale: Maybe(u8) = 4
			disp: Maybe(i32) = 0x1234
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R14, addr)
		},
	)

	// 10. Special Cases

	// 10a. RSP as base (requires SIB)
	compare_bytecode(
		t,
		"mov r15, [rsp+0x42]",
		asm_to_bytes("mov r15, qword ptr [rsp+0x42]"),
		proc() {
			base: Maybe(Register64) = Register64.RSP
			disp: Maybe(i32) = 0x42
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R15, addr)
		},
	)

	// 10b. R12 as base (requires SIB)
	compare_bytecode(t, "mov rax, [r12]", asm_to_bytes("mov rax, qword ptr [r12]"), proc() {
		base: Maybe(Register64) = Register64.R12
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 10c. RBP as base (requires displacement)
	compare_bytecode(t, "mov rbx, [rbp]", asm_to_bytes("mov rbx, qword ptr [rbp+0]"), proc() {
		base: Maybe(Register64) = Register64.RBP
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RBX, addr)
	})

	// 10d. R13 as base (requires displacement)
	compare_bytecode(t, "mov rcx, [r13]", asm_to_bytes("mov rcx, qword ptr [r13+0]"), proc() {
		base: Maybe(Register64) = Register64.R13
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RCX, addr)
	})

	// 11. Index only (no base) with scale
	compare_bytecode(
		t,
		"mov rdx, [r14*8+0x1000]",
		asm_to_bytes("mov rdx, qword ptr [r14*8+0x1000]"),
		proc() {
			index: Maybe(Register64) = Register64.R14
			scale: Maybe(u8) = 8
			disp: Maybe(i32) = 0x1000
			components := AddressComponents {
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RDX, addr)
		},
	)

	// 12. No base or index, just displacement (absolute addressing)
	compare_bytecode(
		t,
		"mov rsi, [0x12345678]",
		asm_to_bytes("mov rsi, qword ptr [rip+0x12345678]"),
		proc() {
			addr: MemoryAddress = 0x12345678
			mov_r64_m64(Register64.RSI, addr)
		},
	)
}

@(test)
test_mov_m64_r64_comprehensive :: proc(t: ^testing.T) {
	// 1. Simple register indirect addressing
	compare_bytecode(t, "mov [rbx], rax", asm_to_bytes("mov qword ptr [rbx], rax"), proc() {
		base: Maybe(Register64) = Register64.RBX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_m64_r64(addr, Register64.RAX)
	})

	// 2. Register + 8-bit displacement
	compare_bytecode(
		t,
		"mov [rdx+0x7F], rcx",
		asm_to_bytes("mov qword ptr [rdx+0x7F], rcx"),
		proc() {
			base: Maybe(Register64) = Register64.RDX
			disp: Maybe(i32) = 0x7F
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_m64_r64(addr, Register64.RCX)
		},
	)

	// 3. Register + 32-bit displacement
	compare_bytecode(
		t,
		"mov [rdi+0x12345678], r8",
		asm_to_bytes("mov qword ptr [rdi+0x12345678], r8"),
		proc() {
			base: Maybe(Register64) = Register64.RDI
			disp: Maybe(i32) = 0x12345678
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_m64_r64(addr, Register64.R8)
		},
	)

	// 4. SIB - Base + Index
	compare_bytecode(t, "mov [rax+rcx], r9", asm_to_bytes("mov qword ptr [rax+rcx], r9"), proc() {
		base: Maybe(Register64) = Register64.RAX
		index: Maybe(Register64) = Register64.RCX
		scale: Maybe(u8) = 1
		components := AddressComponents {
			base  = base,
			index = index,
			scale = scale,
		}
		addr: MemoryAddress = components
		mov_m64_r64(addr, Register64.R9)
	})

	// 5. SIB - Base + Index*2
	compare_bytecode(
		t,
		"mov [rbx+rdx*2], r10",
		asm_to_bytes("mov qword ptr [rbx+rdx*2], r10"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			index: Maybe(Register64) = Register64.RDX
			scale: Maybe(u8) = 2
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_m64_r64(addr, Register64.R10)
		},
	)

	// More complex cases with special registers

	// 6. RSP as base
	compare_bytecode(
		t,
		"mov [rsp+0x20], r11",
		asm_to_bytes("mov qword ptr [rsp+0x20], r11"),
		proc() {
			base: Maybe(Register64) = Register64.RSP
			disp: Maybe(i32) = 0x20
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_m64_r64(addr, Register64.R11)
		},
	)

	// 7. RBP as base (requires displacement)
	compare_bytecode(t, "mov [rbp], r12", asm_to_bytes("mov qword ptr [rbp+0], r12"), proc() {
		base: Maybe(Register64) = Register64.RBP
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_m64_r64(addr, Register64.R12)
	})

	// 8. SIB with scale and displacement
	compare_bytecode(
		t,
		"mov [rsi+r15*8+0x100], r13",
		asm_to_bytes("mov qword ptr [rsi+r15*8+0x100], r13"),
		proc() {
			base: Maybe(Register64) = Register64.RSI
			index: Maybe(Register64) = Register64.R15
			scale: Maybe(u8) = 8
			disp: Maybe(i32) = 0x100
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_m64_r64(addr, Register64.R13)
		},
	)

	// 9. Absolute address
	compare_bytecode(
		t,
		"mov [0x12345678], r14",
		asm_to_bytes("mov qword ptr [rip+0x12345678], r14"),
		proc() {
			addr: MemoryAddress = 0x12345678
			mov_m64_r64(addr, Register64.R14)
		},
	)
}

@(test)
test_mov_with_edge_cases :: proc(t: ^testing.T) {
	// 1. Negative 8-bit displacement
	compare_bytecode(
		t,
		"mov rbx, [rax-0x10]",
		asm_to_bytes("mov rbx, qword ptr [rax-0x10]"),
		proc() {
			base: Maybe(Register64) = Register64.RAX
			disp: Maybe(i32) = -0x10
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RBX, addr)
		},
	)

	// 2. Negative 32-bit displacement
	compare_bytecode(
		t,
		"mov rsi, [rdx-0x12345]",
		asm_to_bytes("mov rsi, qword ptr [rdx-0x12345]"),
		proc() {
			base: Maybe(Register64) = Register64.RDX
			disp: Maybe(i32) = -0x12345
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RSI, addr)
		},
	)

	// 3. 8-bit displacement boundary (127)
	compare_bytecode(
		t,
		"mov rax, [rbx+0x7F]",
		asm_to_bytes("mov rax, qword ptr [rbx+0x7F]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = 0x7F
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 4. 8-bit displacement boundary (128 - should switch to 32-bit encoding)
	compare_bytecode(
		t,
		"mov rax, [rbx+0x80]",
		asm_to_bytes("mov rax, qword ptr [rbx+0x80]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = 0x80
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 5. 8-bit negative displacement boundary (-128)
	compare_bytecode(
		t,
		"mov rax, [rbx-0x80]",
		asm_to_bytes("mov rax, qword ptr [rbx-0x80]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = -0x80
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 6. 8-bit negative displacement boundary (-129 - should switch to 32-bit encoding)
	compare_bytecode(
		t,
		"mov rax, [rbx-0x81]",
		asm_to_bytes("mov rax, qword ptr [rbx-0x81]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = -0x81
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 7. Extended registers (R8-R15) as base/index
	compare_bytecode(
		t,
		"mov rax, [r8+r9*4+0x10]",
		asm_to_bytes("mov rax, qword ptr [r8+r9*4+0x10]"),
		proc() {
			base: Maybe(Register64) = Register64.R8
			index: Maybe(Register64) = Register64.R9
			scale: Maybe(u8) = 4
			disp: Maybe(i32) = 0x10
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 8. Explicit zero displacement with RBP
	compare_bytecode(t, "mov rax, [rbp+0]", asm_to_bytes("mov rax, qword ptr [rbp+0]"), proc() {
		base: Maybe(Register64) = Register64.RBP
		disp: Maybe(i32) = 0
		components := AddressComponents {
			base         = base,
			displacement = disp,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 9. Index-only addressing (with scale=1)
	compare_bytecode(
		t,
		"mov rdx, [rcx*1+0x1000]",
		asm_to_bytes("mov rdx, qword ptr [rcx+0x1000]"),
		proc() {
			index: Maybe(Register64) = Register64.RCX
			scale: Maybe(u8) = 1
			disp: Maybe(i32) = 0x1000
			components := AddressComponents {
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RDX, addr)
		},
	)

	// 10. Maximum 32-bit displacement
	compare_bytecode(
		t,
		"mov rax, [rbx+0x7FFFFFFF]",
		asm_to_bytes("mov rax, qword ptr [rbx+0x7FFFFFFF]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = 0x7FFFFFFF
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 11. Minimum 32-bit displacement
	compare_bytecode(
		t,
		"mov rax, [rbx-0x80000000]",
		asm_to_bytes("mov rax, qword ptr [rbx-0x80000000]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = -0x80000000
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)
}

// Comprehensive testing of rip-relative addressing and memory operand formats
@(test)
test_mov_rip_relative_addressing :: proc(t: ^testing.T) {
	// 1. Basic RIP-relative addressing
	compare_bytecode(
		t,
		"mov rax, [rip+0x1000]",
		asm_to_bytes("mov rax, qword ptr [rip+0x1000]"),
		proc() {
			addr: MemoryAddress = 0x1000
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// // 2. RIP-relative with negative offset
	// compare_bytecode(
	// 	t,
	// 	"mov rbx, [rip-0x1000]",
	// 	asm_to_bytes("mov rbx, qword ptr [rip-0x1000]"),
	// 	proc() {
	// 		addr: MemoryAddress = -0x1000
	// 		mov_r64_m64(Register64.RBX, addr)
	// 	},
	// )

	// 3. RIP-relative with larger offset
	compare_bytecode(
		t,
		"mov rcx, [rip+0x12345678]",
		asm_to_bytes("mov rcx, qword ptr [rip+0x12345678]"),
		proc() {
			addr: MemoryAddress = 0x12345678
			mov_r64_m64(Register64.RCX, addr)
		},
	)
}

// Testing different REX prefix combinations
@(test)
test_rex_prefix_combinations :: proc(t: ^testing.T) {
	// 1. REX.W (64-bit operand) with base registers
	compare_bytecode(t, "mov rax, [rbx]", asm_to_bytes("mov rax, qword ptr [rbx]"), proc() {
		base: Maybe(Register64) = Register64.RBX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 2. REX.R (extended register in reg field)
	compare_bytecode(t, "mov r8, [rax]", asm_to_bytes("mov r8, qword ptr [rax]"), proc() {
		base: Maybe(Register64) = Register64.RAX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.R8, addr)
	})

	// 3. REX.B (extended register in r/m field)
	compare_bytecode(t, "mov rax, [r8]", asm_to_bytes("mov rax, qword ptr [r8]"), proc() {
		base: Maybe(Register64) = Register64.R8
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 4. REX.X (extended register in index field)
	compare_bytecode(
		t,
		"mov rax, [rbx+r8*4]",
		asm_to_bytes("mov rax, qword ptr [rbx+r8*4]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			index: Maybe(Register64) = Register64.R8
			scale: Maybe(u8) = 4
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 5. Combined REX.W + REX.R + REX.X + REX.B
	compare_bytecode(
		t,
		"mov r15, [r14+r13*8+0x42]",
		asm_to_bytes("mov r15, qword ptr [r14+r13*8+0x42]"),
		proc() {
			base: Maybe(Register64) = Register64.R14
			index: Maybe(Register64) = Register64.R13
			scale: Maybe(u8) = 8
			disp: Maybe(i32) = 0x42
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R15, addr)
		},
	)
}

// Special case addressing modes
@(test)
test_special_case_addressing :: proc(t: ^testing.T) {
	// 1. RBP/R13 requiring displacement even when disp=0
	compare_bytecode(t, "mov rax, [rbp]", asm_to_bytes("mov rax, qword ptr [rbp+0]"), proc() {
		base: Maybe(Register64) = Register64.RBP
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	compare_bytecode(t, "mov rax, [r13]", asm_to_bytes("mov rax, qword ptr [r13+0]"), proc() {
		base: Maybe(Register64) = Register64.R13
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 2. RSP/R12 requiring SIB byte
	compare_bytecode(t, "mov rax, [rsp]", asm_to_bytes("mov rax, qword ptr [rsp]"), proc() {
		base: Maybe(Register64) = Register64.RSP
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	compare_bytecode(t, "mov rax, [r12]", asm_to_bytes("mov rax, qword ptr [r12]"), proc() {
		base: Maybe(Register64) = Register64.R12
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 3. No base but with SIB (index * scale + displacement)
	compare_bytecode(
		t,
		"mov rax, [rcx*4+0x1000]",
		asm_to_bytes("mov rax, qword ptr [rcx*4+0x1000]"),
		proc() {
			index: Maybe(Register64) = Register64.RCX
			scale: Maybe(u8) = 4
			disp: Maybe(i32) = 0x1000
			components := AddressComponents {
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 4. SIB byte with no index (encoded as RSP)
	compare_bytecode(
		t,
		"mov rax, [rbx+0x10]",
		asm_to_bytes("mov rax, qword ptr [rbx+0x10]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = 0x10
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)
}

// Testing with reversed operand ordering for mov instructions
@(test)
test_mov_operand_ordering :: proc(t: ^testing.T) {
	// 1. Register to memory
	compare_bytecode(t, "mov [rbx], rax", asm_to_bytes("mov qword ptr [rbx], rax"), proc() {
		base: Maybe(Register64) = Register64.RBX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_m64_r64(addr, Register64.RAX)
	})

	// 2. Memory to register
	compare_bytecode(t, "mov rax, [rbx]", asm_to_bytes("mov rax, qword ptr [rbx]"), proc() {
		base: Maybe(Register64) = Register64.RBX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})
}

// Test registers that need specific handling in SIB
@(test)
test_sib_special_registers :: proc(t: ^testing.T) {
	// 1. RSP cannot be an index register (assembler would reject this)
	// Instead, test RBP as index
	compare_bytecode(
		t,
		"mov rax, [rcx+rbp*2]",
		asm_to_bytes("mov rax, qword ptr [rcx+rbp*2]"),
		proc() {
			base: Maybe(Register64) = Register64.RCX
			index: Maybe(Register64) = Register64.RBP
			scale: Maybe(u8) = 2
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 2. R12 as base (requires SIB with no index)
	compare_bytecode(
		t,
		"mov rax, [r12+0x42]",
		asm_to_bytes("mov rax, qword ptr [r12+0x42]"),
		proc() {
			base: Maybe(Register64) = Register64.R12
			disp: Maybe(i32) = 0x42
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 3. R13 as base with no displacement (needs an explicit zero displacement)
	compare_bytecode(t, "mov rax, [r13]", asm_to_bytes("mov rax, qword ptr [r13+0]"), proc() {
		base: Maybe(Register64) = Register64.R13
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})
}

// Test complex combinations
@(test)
test_complex_addressing_combinations :: proc(t: ^testing.T) {
	// 1. Complex SIB with extended registers and displacement
	compare_bytecode(
		t,
		"mov r15, [r14+r13*8+0x12345678]",
		asm_to_bytes("mov r15, qword ptr [r14+r13*8+0x12345678]"),
		proc() {
			base: Maybe(Register64) = Register64.R14
			index: Maybe(Register64) = Register64.R13
			scale: Maybe(u8) = 8
			disp: Maybe(i32) = 0x12345678
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R15, addr)
		},
	)

	// 2. SIB with RSP as base and extended register as index
	compare_bytecode(
		t,
		"mov rax, [rsp+r9*4]",
		asm_to_bytes("mov rax, qword ptr [rsp+r9*4]"),
		proc() {
			base: Maybe(Register64) = Register64.RSP
			index: Maybe(Register64) = Register64.R9
			scale: Maybe(u8) = 4
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 3. RBP as base with index and displacement
	compare_bytecode(
		t,
		"mov rbx, [rbp+rcx*2+0x42]",
		asm_to_bytes("mov rbx, qword ptr [rbp+rcx*2+0x42]"),
		proc() {
			base: Maybe(Register64) = Register64.RBP
			index: Maybe(Register64) = Register64.RCX
			scale: Maybe(u8) = 2
			disp: Maybe(i32) = 0x42
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RBX, addr)
		},
	)

	// 4. Extended registers for base, index, and reg field
	compare_bytecode(
		t,
		"mov r10, [r11+r12*4+0x100]",
		asm_to_bytes("mov r10, qword ptr [r11+r12*4+0x100]"),
		proc() {
			base: Maybe(Register64) = Register64.R11
			index: Maybe(Register64) = Register64.R12
			scale: Maybe(u8) = 4
			disp: Maybe(i32) = 0x100
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R10, addr)
		},
	)
}

// Test the boundary conditions for displacement values
@(test)
test_displacement_boundaries :: proc(t: ^testing.T) {
	// 1. Displacement 0 (no displacement in encoding except for special cases)
	compare_bytecode(t, "mov rax, [rbx+0]", asm_to_bytes("mov rax, qword ptr [rbx]"), proc() {
		base: Maybe(Register64) = Register64.RBX
		disp: Maybe(i32) = 0
		components := AddressComponents {
			base         = base,
			displacement = disp,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 2. Smallest 8-bit displacement (1)
	compare_bytecode(t, "mov rax, [rbx+1]", asm_to_bytes("mov rax, qword ptr [rbx+1]"), proc() {
		base: Maybe(Register64) = Register64.RBX
		disp: Maybe(i32) = 1
		components := AddressComponents {
			base         = base,
			displacement = disp,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 3. Largest 8-bit displacement (127)
	compare_bytecode(
		t,
		"mov rax, [rbx+127]",
		asm_to_bytes("mov rax, qword ptr [rbx+127]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = 127
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 4. Smallest 32-bit displacement (128)
	compare_bytecode(
		t,
		"mov rax, [rbx+128]",
		asm_to_bytes("mov rax, qword ptr [rbx+128]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = 128
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 5. Smallest negative 8-bit displacement (-1)
	compare_bytecode(t, "mov rax, [rbx-1]", asm_to_bytes("mov rax, qword ptr [rbx-1]"), proc() {
		base: Maybe(Register64) = Register64.RBX
		disp: Maybe(i32) = -1
		components := AddressComponents {
			base         = base,
			displacement = disp,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 6. Largest negative 8-bit displacement (-128)
	compare_bytecode(
		t,
		"mov rax, [rbx-128]",
		asm_to_bytes("mov rax, qword ptr [rbx-128]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = -128
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 7. Smallest negative 32-bit displacement (-129)
	compare_bytecode(
		t,
		"mov rax, [rbx-129]",
		asm_to_bytes("mov rax, qword ptr [rbx-129]"),
		proc() {
			base: Maybe(Register64) = Register64.RBX
			disp: Maybe(i32) = -129
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)
}

// Additional tests for REX prefixes ensuring they're generated correctly
@(test)
test_comprehensive_rex_prefixes :: proc(t: ^testing.T) {
	// 1. REX.W only (64-bit operand)
	compare_bytecode(t, "mov rax, [rbx]", asm_to_bytes("mov rax, qword ptr [rbx]"), proc() {
		base: Maybe(Register64) = Register64.RBX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 2. REX.W + REX.R (64-bit + extended register in reg field)
	compare_bytecode(t, "mov r8, [rcx]", asm_to_bytes("mov r8, qword ptr [rcx]"), proc() {
		base: Maybe(Register64) = Register64.RCX
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.R8, addr)
	})

	// 3. REX.W + REX.B (64-bit + extended register in r/m field)
	compare_bytecode(t, "mov rax, [r8]", asm_to_bytes("mov rax, qword ptr [r8]"), proc() {
		base: Maybe(Register64) = Register64.R8
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.RAX, addr)
	})

	// 4. REX.W + REX.X (64-bit + extended register in SIB.index)
	compare_bytecode(
		t,
		"mov rax, [rcx+r8*4]",
		asm_to_bytes("mov rax, qword ptr [rcx+r8*4]"),
		proc() {
			base: Maybe(Register64) = Register64.RCX
			index: Maybe(Register64) = Register64.R8
			scale: Maybe(u8) = 4
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 5. REX.W + REX.R + REX.B (64-bit + extended reg + extended r/m)
	compare_bytecode(t, "mov r8, [r9]", asm_to_bytes("mov r8, qword ptr [r9]"), proc() {
		base: Maybe(Register64) = Register64.R9
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.R8, addr)
	})

	// 6. REX.W + REX.R + REX.X (64-bit + extended reg + extended index)
	compare_bytecode(
		t,
		"mov r8, [rcx+r9*4]",
		asm_to_bytes("mov r8, qword ptr [rcx+r9*4]"),
		proc() {
			base: Maybe(Register64) = Register64.RCX
			index: Maybe(Register64) = Register64.R9
			scale: Maybe(u8) = 4
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R8, addr)
		},
	)

	// 7. REX.W + REX.X + REX.B (64-bit + extended index + extended base)
	compare_bytecode(
		t,
		"mov rax, [r10+r11*4]",
		asm_to_bytes("mov rax, qword ptr [r10+r11*4]"),
		proc() {
			base: Maybe(Register64) = Register64.R10
			index: Maybe(Register64) = Register64.R11
			scale: Maybe(u8) = 4
			components := AddressComponents {
				base  = base,
				index = index,
				scale = scale,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.RAX, addr)
		},
	)

	// 8. Full REX prefix (REX.W + REX.R + REX.X + REX.B)
	compare_bytecode(
		t,
		"mov r12, [r13+r14*8+0x42]",
		asm_to_bytes("mov r12, qword ptr [r13+r14*8+0x42]"),
		proc() {
			base: Maybe(Register64) = Register64.R13
			index: Maybe(Register64) = Register64.R14
			scale: Maybe(u8) = 8
			disp: Maybe(i32) = 0x42
			components := AddressComponents {
				base         = base,
				index        = index,
				scale        = scale,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R12, addr)
		},
	)
}

// Tests specifically for the special encoding requirements of different registers
@(test)
test_register_special_encodings :: proc(t: ^testing.T) {
	// 1. RSP as base (requires SIB byte) with extended register
	compare_bytecode(
		t,
		"mov r10, [rsp+0x10]",
		asm_to_bytes("mov r10, qword ptr [rsp+0x10]"),
		proc() {
			base: Maybe(Register64) = Register64.RSP
			disp: Maybe(i32) = 0x10
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R10, addr)
		},
	)

	// 2. R12 as base (requires SIB byte) with extended register
	compare_bytecode(
		t,
		"mov r11, [r12+0x20]",
		asm_to_bytes("mov r11, qword ptr [r12+0x20]"),
		proc() {
			base: Maybe(Register64) = Register64.R12
			disp: Maybe(i32) = 0x20
			components := AddressComponents {
				base         = base,
				displacement = disp,
			}
			addr: MemoryAddress = components
			mov_r64_m64(Register64.R11, addr)
		},
	)

	// 3. RBP as base (requires displacement) with extended register
	compare_bytecode(t, "mov r9, [rbp]", asm_to_bytes("mov r9, qword ptr [rbp+0]"), proc() {
		base: Maybe(Register64) = Register64.RBP
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.R9, addr)
	})

	// 4. R13 as base (requires displacement) with extended register
	compare_bytecode(t, "mov r8, [r13]", asm_to_bytes("mov r8, qword ptr [r13+0]"), proc() {
		base: Maybe(Register64) = Register64.R13
		components := AddressComponents {
			base = base,
		}
		addr: MemoryAddress = components
		mov_r64_m64(Register64.R8, addr)
	})
}

// --------------------------------
// Complex Instruction Sequences
// --------------------------------
@(test)
test_mov_combinations_basic :: proc(t: ^testing.T) {
	// Test basic instruction sequences

	// Load immediate then move register
	compare_bytecode(
		t,
		"mov rax, 0xDEADBEEF\nmov rbx, rax",
		asm_to_bytes("mov rax, 0xDEADBEEF\nmov rbx, rax"),
		proc() {
			mov_r64_imm64(Register64.RAX, 0xDEADBEEF)
			mov_r64_r64(Register64.RBX, Register64.RAX)
		},
	)

	// Memory to register to memory
	compare_bytecode(
		t,
		"mov r10, [0x1234]\nmov [0x5678], r10",
		asm_to_bytes("mov r10, qword ptr [rip+0x1234]\nmov qword ptr [rip+0x5678], r10"),
		proc() {
			mov_r64_m64(Register64.R10, 0x1234)
			mov_m64_r64(0x5678, Register64.R10)
		},
	)

	// Extended registers interactions
	compare_bytecode(
		t,
		"mov r8, 0x42\nmov r9, r8\nmov [0xABCD], r9",
		asm_to_bytes("mov r8, 0x42\nmov r9, r8\nmov qword ptr [rip+0xABCD], r9"),
		proc() {
			mov_r64_imm64(Register64.R8, 0x42)
			mov_r64_r64(Register64.R9, Register64.R8)
			mov_m64_r64(0xABCD, Register64.R9)
		},
	)
}

@(test)
test_mov_combinations_advanced :: proc(t: ^testing.T) {
	// Test complex instruction sequences

	// Various immediate encodings
	compare_bytecode(
		t,
		"mov rax, 0x7FFFFFFF\nmov rbx, 0x80000000\nmov rcx, 0xFFFFFFFF",
		asm_to_bytes("mov rax, 0x7FFFFFFF\nmov rbx, 0x80000000\nmov rcx, 0xFFFFFFFF"),
		proc() {
			mov_r64_imm64(Register64.RAX, 0x7FFFFFFF) // Fits in 32-bit positive
			mov_r64_imm64(Register64.RBX, 0x80000000) // 32-bit sign boundary
			mov_r64_imm64(Register64.RCX, 0xFFFFFFFF) // All 32-bit bits set
		},
	)

	// Memory and register operations
	compare_bytecode(
		t,
		"mov r8, 0x12345678\nmov [0x1000], r8\nmov rax, [0x1000]\nmov rbx, rax",
		asm_to_bytes(
			"mov r8, 0x12345678\nmov qword ptr [rip+0x1000], r8\nmov rax, qword ptr [rip+0x1000]\nmov rbx, rax",
		),
		proc() {
			mov_r64_imm64(Register64.R8, 0x12345678)
			mov_m64_r64(0x1000, Register64.R8)
			mov_r64_m64(Register64.RAX, 0x1000)
			mov_r64_r64(Register64.RBX, Register64.RAX)
		},
	)

	// Special registers in combinations
	compare_bytecode(
		t,
		"mov r12, 0xABCDEF\nmov rsp, r12\nmov [0x2000], rsp\nmov rbp, [0x2000]",
		asm_to_bytes(
			"mov r12, 0xABCDEF\nmov rsp, r12\nmov qword ptr [rip+0x2000], rsp\nmov rbp, qword ptr [rip+0x2000]",
		),
		proc() {
			mov_r64_imm64(Register64.R12, 0xABCDEF) // Extended register
			mov_r64_r64(Register64.RSP, Register64.R12) // Target RSP (special)
			mov_m64_r64(0x2000, Register64.RSP) // Source RSP (special)
			mov_r64_m64(Register64.RBP, 0x2000) // Target RBP (special)
		},
	)
}
