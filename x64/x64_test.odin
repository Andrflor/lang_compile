///////////////////////////////////////////////////////////////////////////////
//
// x86-64 Assembly Instruction Set Tests
//
// This file contains unit tests for verifying the correctness of x86-64
// assembly instruction encoding.
//
// Author: Florian Andrieu <andrieu.florian@mail.com>
///////////////////////////////////////////////////////////////////////////////
package x64_assembler

import "core:fmt"
import "core:log"
import "core:testing"

// ==================================
// TESTING UTILITIES
// ==================================

// Callback type for executing test cases
VoidCallback :: proc()

// Compares generated bytecode with expected output
// Logs mismatches and marks test as failed if bytes differ
compare_bytecode :: proc(t: ^testing.T, desc: string, expected: []u8) {
	// Validate length
	if len(expected) != _buffer.len {
		log.info(
			desc,
			": Length mismatch. Expected",
			expected,
			"bytes, got",
			_buffer.data[:_buffer.len],
			"bytes.",
		)
		resetBuffer()
		testing.fail(t)
		return
	}

	// Validate byte content
	for i in 0 ..< len(expected) {
		if expected[i] != _buffer.data[i] {
			log.infof(
				"%s: Byte mismatch at position %d. Expected %i, got %i.\n",
				desc,
				i,
				expected,
				_buffer.data[:_buffer.len],
			)
			resetBuffer()
			testing.fail(t)
			return
		}
	}

	// Reset buffer for next test case
	resetBuffer()
}


// ==================================
// X86-64 MOV INSTRUCTION TESTS
// ==================================

// --------------------------------
// Basic Register-Immediate Tests
// --------------------------------
@(test)
test_r64_m64 :: proc(t: ^testing.T) {
	addresses := get_all_addressing_combinations()
	defer delete(addresses)
	registers64 := get_all_registers64()

	for dst in registers64 {
		for src in addresses {
			asm_str := fmt.tprintf(
				"mov %s, %s",
				register64_to_string(dst),
				memory_address_to_string(src),
			)
			log.info(asm_str)
			mov_r64_m64(dst, src)
			compare_bytecode(t, asm_str, asm_to_bytes(asm_str))
		}
	}
}
