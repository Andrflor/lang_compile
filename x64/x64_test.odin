///////////////////////////////////////////////////////////////////////////////
//
// x86-64 Assembly Instruction Set Tests
//
// This file contains unit tests for verifying the correctness of x86-64
// assembly instruction encoding.
//
// Author: Florian Andrieu <andrieu.florian@mail.com>
///////////////////////////////////////////////////////////////////////////////
package x64_assembler

import "core:fmt"
import "core:log"
import "core:math/rand"
import "core:testing"

// ==================================
// TESTING UTILITIES
// ==================================

// Callback type for executing test cases
VoidCallback :: proc()

// Compares generated bytecode with expected output
// Logs mismatches and marks test as failed if bytes differ
compare_bytecode :: proc(t: ^testing.T, desc: string, expected: []u8) {
	// Validate length
	buffer := (^ByteBuffer)(context.user_ptr)
	if len(expected) != buffer.len {
		log.error(
			desc,
			": Length mismatch. Expected",
			expected,
			"bytes, got",
			buffer.data[:buffer.len],
			"bytes.",
		)
		testing.fail(t)
		return
	}

	// Validate byte content
	for i in 0 ..< len(expected) {
		if expected[i] != buffer.data[i] {
			log.errorf(
				"%s: Byte mismatch at position %d. Expected %i, got %i.\n",
				desc,
				i,
				expected,
				buffer.data[:buffer.len],
			)
			testing.fail(t)
			return
		}
	}
}


// ==================================
// X86-64 MOV INSTRUCTION TESTS
// ==================================
// --------------------------------
// 64 bits test
// --------------------------------
@(test)
testing_r64_r64 :: proc(t: ^testing.T) {
	registers64 := get_all_registers64()
	for dst in registers64 {
		for src in registers64 {
			asm_str := fmt.tprintf(
				"mov %s, %s",
				register64_to_string(dst),
				register64_to_string(src),
			)
			buffer := ByteBuffer{}
			context.user_ptr = &buffer
			mov_r64_r64(dst, src)
			compare_bytecode(t, asm_str, asm_to_bytes(asm_str))
		}
	}
}

@(test)
testing_r64_imm64 :: proc(t: ^testing.T) {
	registers64 := get_all_registers64()
	interestingImm64 := get_interesting_imm64_values()
	for dst in registers64 {
		for src in interestingImm64 {
			asm_str := fmt.tprintf("mov %s, %d", register64_to_string(dst), src)
			buffer := ByteBuffer{}
			context.user_ptr = &buffer
			mov_r64_imm64(dst, src)
			compare_bytecode(t, asm_str, asm_to_bytes(asm_str))
		}
	}
}

@(test)
testing_r64_m64 :: proc(t: ^testing.T) {
	addresses := get_all_addressing_combinations()
	defer delete(addresses)
	registers64 := get_all_registers64()

	// Set the number of random tests to run
	num_tests := 400

	for i := 0; i < num_tests; i += 1 {
		// Select a random register
		dst_idx := rand.int_max(len(registers64))
		dst := registers64[dst_idx]

		// Select a random memory addressing mode
		src_idx := rand.int_max(len(addresses))
		src := addresses[src_idx]

		asm_str := fmt.tprintf(
			"mov %s, %s",
			register64_to_string(dst),
			memory_address_to_string(src),
		)
		buffer := ByteBuffer{}
		context.user_ptr = &buffer
		mov_r64_m64(dst, src)
		compare_bytecode(t, asm_str, asm_to_bytes(asm_str))
	}
}
