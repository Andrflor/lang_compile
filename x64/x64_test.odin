///////////////////////////////////////////////////////////////////////////////
//
// x86-64 Assembly Instruction Set Tests
//
// This file contains unit tests for verifying the correctness of x86-64
// assembly instruction encoding.
//
// Author: Florian Andrieu <andrieu.florian@mail.com>
///////////////////////////////////////////////////////////////////////////////
package x64_assembler

import "core:fmt"
import "core:log"
import "core:testing"

// ==================================
// TESTING UTILITIES
// ==================================

// Callback type for executing test cases
VoidCallback :: proc()

// Compares generated bytecode with expected output
// Logs mismatches and marks test as failed if bytes differ
compare_bytecode :: proc(t: ^testing.T, desc: string, expected: []u8, writer: VoidCallback) {
	// Execute the instruction writer to generate bytecode
	writer()

	// Validate length
	if len(expected) != _buffer.len {
		log.info(
			desc,
			": Length mismatch. Expected",
			expected,
			"bytes, got",
			_buffer.data[:_buffer.len],
			"bytes.",
		)
		resetBuffer()
		testing.fail(t)
		return
	}

	// Validate byte content
	for i in 0 ..< len(expected) {
		if expected[i] != _buffer.data[i] {
			log.infof(
				"%s: Byte mismatch at position %d. Expected 0x%02X, got 0x%02X.\n",
				desc,
				i,
				expected[i],
				_buffer.data[i],
			)
			resetBuffer()
			testing.fail(t)
			return
		}
	}

	// Reset buffer for next test case
	resetBuffer()
}

// ==================================
// X86-64 MOV INSTRUCTION TESTS
// ==================================

// --------------------------------
// Basic Register-Immediate Tests
// --------------------------------
@(test)
test_mov_r64_imm64_basic :: proc(t: ^testing.T) {
	// Test basic immediate to register moves

	// RAX with large immediate
	compare_bytecode(
		t,
		"mov rax, 0x123456789ABCDEF0",
		asm_to_bytes("mov rax, 0x123456789ABCDEF0"),
		proc() {mov_r64_imm64(Register64.RAX, 0x123456789ABCDEF0)},
	)

	// RBX with large positive value
	compare_bytecode(
		t,
		"mov rbx, 0x7FFFFFFFFFFFFFFF",
		asm_to_bytes("mov rbx, 0x7FFFFFFFFFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RBX, 0x7FFFFFFFFFFFFFFF)},
	)

	// Small values
	compare_bytecode(
		t,
		"mov r8, 0x1",
		asm_to_bytes("mov r8, 0x1"),
		proc() {mov_r64_imm64(Register64.R8, 0x1)},
	)

	compare_bytecode(
		t,
		"mov rsp, 0x0",
		asm_to_bytes("mov rsp, 0x0"),
		proc() {mov_r64_imm64(Register64.RSP, 0x0)},
	)

	compare_bytecode(
		t,
		"mov rdi, 0x42",
		asm_to_bytes("mov rdi, 0x42"),
		proc() {mov_r64_imm64(Register64.RDI, 0x42)},
	)

	// 32-bit value on extended register
	compare_bytecode(
		t,
		"mov r15, 0x7FFFFFFF",
		asm_to_bytes("mov r15, 0x7FFFFFFF"),
		proc() {mov_r64_imm64(Register64.R15, 0x7FFFFFFF)},
	)
}

// --------------------------------
// Edge Cases for Immediate Values
// --------------------------------
@(test)
test_mov_r64_imm64_edge_cases :: proc(t: ^testing.T) {
	// Test boundary values and edge cases for immediate to register moves

	// 32-bit boundary values
	compare_bytecode(
		t,
		"mov rax, 0xFFFFFFFF", // 32-bit all ones
		asm_to_bytes("mov rax, 0xFFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RAX, 0xFFFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov r9, 0x7FFFFFFF", // Maximum positive 32-bit signed integer
		asm_to_bytes("mov r9, 0x7FFFFFFF"),
		proc() {mov_r64_imm64(Register64.R9, 0x7FFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov r10, 0x80000000", // Minimum negative 32-bit signed integer
		asm_to_bytes("mov r10, 0x80000000"),
		proc() {mov_r64_imm64(Register64.R10, 0x80000000)},
	)

	// Values that can't be represented as sign-extended 32-bit
	compare_bytecode(
		t,
		"mov rbx, 0x80000000", // Just above 32-bit positive range
		asm_to_bytes("mov rbx, 0x80000000"),
		proc() {mov_r64_imm64(Register64.RBX, 0x80000000)},
	)

	compare_bytecode(
		t,
		"mov rcx, 0xFFFFFFFF7FFFFFFF", // Just below 32-bit negative range
		asm_to_bytes("mov rcx, 0xFFFFFFFF7FFFFFFF"),
		proc() {mov_r64_imm64(Register64.RCX, 0xFFFFFFFF7FFFFFFF)},
	)

	// Interesting bit patterns
	compare_bytecode(
		t,
		"mov rdx, 0xFFFFFFFF00000000", // Upper 32 bits all ones, lower 32 bits zeros
		asm_to_bytes("mov rdx, 0xFFFFFFFF00000000"),
		proc() {mov_r64_imm64(Register64.RDX, 0xFFFFFFFF00000000)},
	)

	compare_bytecode(
		t,
		"mov rsi, 0x00000000FFFFFFFF", // Upper 32 bits zeros, lower 32 bits all ones
		asm_to_bytes("mov rsi, 0x00000000FFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RSI, 0x00000000FFFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov rdi, 0xFFFFFFFFFFFFFFFF", // Maximum 64-bit unsigned value
		asm_to_bytes("mov rdi, 0xFFFFFFFFFFFFFFFF"),
		proc() {mov_r64_imm64(Register64.RDI, 0xFFFFFFFFFFFFFFFF)},
	)

	compare_bytecode(
		t,
		"mov r8, 0xAAAAAAAAAAAAAAAA", // Alternating bit pattern
		asm_to_bytes("mov r8, 0xAAAAAAAAAAAAAAAA"),
		proc() {mov_r64_imm64(Register64.R8, 0xAAAAAAAAAAAAAAAA)},
	)
}

// --------------------------------
// Register-to-Register Tests
// --------------------------------
@(test)
test_mov_r64_r64_basic :: proc(t: ^testing.T) {
	// Test basic register to register moves

	// Standard registers
	compare_bytecode(
		t,
		"mov rax, rcx",
		asm_to_bytes("mov rax, rcx"),
		proc() {mov_r64_r64(Register64.RAX, Register64.RCX)},
	)

	// Tests with extended registers
	compare_bytecode(
		t,
		"mov rdx, r8",
		asm_to_bytes("mov rdx, r8"),
		proc() {mov_r64_r64(Register64.RDX, Register64.R8)},
	)

	compare_bytecode(
		t,
		"mov r9, rbx",
		asm_to_bytes("mov r9, rbx"),
		proc() {mov_r64_r64(Register64.R9, Register64.RBX)},
	)

	compare_bytecode(
		t,
		"mov r10, r11",
		asm_to_bytes("mov r10, r11"),
		proc() {mov_r64_r64(Register64.R10, Register64.R11)},
	)
}

@(test)
test_mov_r64_r64_special_registers :: proc(t: ^testing.T) {
	// Test specific cases with RSP, RBP, and other special encodings

	// Same register moves
	compare_bytecode(
		t,
		"mov rax, rax",
		asm_to_bytes("mov rax, rax"),
		proc() {mov_r64_r64(Register64.RAX, Register64.RAX)},
	)

	// RSP as source
	compare_bytecode(
		t,
		"mov rbx, rsp",
		asm_to_bytes("mov rbx, rsp"),
		proc() {mov_r64_r64(Register64.RBX, Register64.RSP)},
	)

	// RSP as destination
	compare_bytecode(
		t,
		"mov rsp, rbx",
		asm_to_bytes("mov rsp, rbx"),
		proc() {mov_r64_r64(Register64.RSP, Register64.RBX)},
	)

	// RBP as source
	compare_bytecode(
		t,
		"mov rcx, rbp",
		asm_to_bytes("mov rcx, rbp"),
		proc() {mov_r64_r64(Register64.RCX, Register64.RBP)},
	)

	// RBP as destination
	compare_bytecode(
		t,
		"mov rbp, rcx",
		asm_to_bytes("mov rbp, rcx"),
		proc() {mov_r64_r64(Register64.RBP, Register64.RCX)},
	)
}

@(test)
test_mov_r64_r64_extended_registers :: proc(t: ^testing.T) {
	// Test combinations with extended registers

	// Extended registers as both source and destination
	compare_bytecode(
		t,
		"mov r12, r13",
		asm_to_bytes("mov r12, r13"),
		proc() {mov_r64_r64(Register64.R12, Register64.R13)},
	)

	// Extended register to standard register
	compare_bytecode(
		t,
		"mov rax, r15",
		asm_to_bytes("mov rax, r15"),
		proc() {mov_r64_r64(Register64.RAX, Register64.R15)},
	)

	// Special and extended register combinations
	compare_bytecode(
		t,
		"mov rsp, r14", // RSP as destination and extended register as source
		asm_to_bytes("mov rsp, r14"),
		proc() {mov_r64_r64(Register64.RSP, Register64.R14)},
	)

	compare_bytecode(
		t,
		"mov r8, rsp", // Extended register as destination and RSP as source
		asm_to_bytes("mov r8, rsp"),
		proc() {mov_r64_r64(Register64.R8, Register64.RSP)},
	)
}

// --------------------------------
// Memory Operations Tests
// --------------------------------
@(test)
test_mov_r64_m64_basic :: proc(t: ^testing.T) {
	// Test memory-to-register operations

	// Standard registers with memory
	compare_bytecode(
		t,
		"mov rax, [0x1000]",
		asm_to_bytes("mov rax, qword ptr [rip+0x1000]"),
		proc() {mov_r64_m64(Register64.RAX, 0x1000)},
	)

	// Extended registers with memory
	compare_bytecode(
		t,
		"mov r8, [0x7FFF]",
		asm_to_bytes("mov r8, qword ptr [rip+0x7FFF]"),
		proc() {mov_r64_m64(Register64.R8, 0x7FFF)},
	)

	// Special registers with memory
	compare_bytecode(
		t,
		"mov rsp, [0x8000]",
		asm_to_bytes("mov rsp, qword ptr [rip+0x8000]"),
		proc() {mov_r64_m64(Register64.RSP, 0x8000)},
	)
}

@(test)
test_mov_r64_m64_address_variations :: proc(t: ^testing.T) {
	// Test memory-to-register operations with different address patterns

	// Small offset
	compare_bytecode(
		t,
		"mov rax, [0xFFF]",
		asm_to_bytes("mov rax, qword ptr [rip+0xFFF]"),
		proc() {mov_r64_m64(Register64.RAX, 0xFFF)},
	)

	// Typical offset
	compare_bytecode(
		t,
		"mov rbx, [0x7FFF]",
		asm_to_bytes("mov rbx, qword ptr [rip+0x7FFF]"),
		proc() {mov_r64_m64(Register64.RBX, 0x7FFF)},
	)

	// Larger offset
	compare_bytecode(
		t,
		"mov rcx, [0x12345]",
		asm_to_bytes("mov rcx, qword ptr [rip+0x12345]"),
		proc() {mov_r64_m64(Register64.RCX, 0x12345)},
	)

	// Page boundary offset
	compare_bytecode(
		t,
		"mov rdx, [0x1000]",
		asm_to_bytes("mov rdx, qword ptr [rip+0x1000]"),
		proc() {mov_r64_m64(Register64.RDX, 0x1000)},
	)

	// Special encoding register
	compare_bytecode(
		t,
		"mov r12, [0x1234]",
		asm_to_bytes("mov r12, qword ptr [rip+0x1234]"),
		proc() {mov_r64_m64(Register64.R12, 0x1234)},
	)
}

@(test)
test_mov_m64_r64_basic :: proc(t: ^testing.T) {
	// Test register-to-memory operations

	// Standard registers with memory
	compare_bytecode(
		t,
		"mov [0x1000], rax",
		asm_to_bytes("mov qword ptr [rip+0x1000], rax"),
		proc() {mov_m64_r64(0x1000, Register64.RAX)},
	)

	// Extended registers with memory
	compare_bytecode(
		t,
		"mov [0x7FFF], r8",
		asm_to_bytes("mov qword ptr [rip+0x7FFF], r8"),
		proc() {mov_m64_r64(0x7FFF, Register64.R8)},
	)

	// Special registers with memory
	compare_bytecode(
		t,
		"mov [0x8000], rsp",
		asm_to_bytes("mov qword ptr [rip+0x8000], rsp"),
		proc() {mov_m64_r64(0x8000, Register64.RSP)},
	)
}

@(test)
test_mov_m64_r64_address_variations :: proc(t: ^testing.T) {
	// Test register-to-memory operations with different address patterns

	// Small offset
	compare_bytecode(
		t,
		"mov [0xFFF], rax",
		asm_to_bytes("mov qword ptr [rip+0xFFF], rax"),
		proc() {mov_m64_r64(0xFFF, Register64.RAX)},
	)

	// Typical offset
	compare_bytecode(
		t,
		"mov [0x7FFF], rbx",
		asm_to_bytes("mov qword ptr [rip+0x7FFF], rbx"),
		proc() {mov_m64_r64(0x7FFF, Register64.RBX)},
	)

	// Larger offset
	compare_bytecode(
		t,
		"mov [0x12345], rcx",
		asm_to_bytes("mov qword ptr [rip+0x12345], rcx"),
		proc() {mov_m64_r64(0x12345, Register64.RCX)},
	)

	// Page boundary offset
	compare_bytecode(
		t,
		"mov [0x1000], rdx",
		asm_to_bytes("mov qword ptr [rip+0x1000], rdx"),
		proc() {mov_m64_r64(0x1000, Register64.RDX)},
	)

	// Special encoding register
	compare_bytecode(
		t,
		"mov [0x1234], r12",
		asm_to_bytes("mov qword ptr [rip+0x1234], r12"),
		proc() {mov_m64_r64(0x1234, Register64.R12)},
	)
}

// --------------------------------
// Complex Instruction Sequences
// --------------------------------
@(test)
test_mov_combinations_basic :: proc(t: ^testing.T) {
	// Test basic instruction sequences

	// Load immediate then move register
	compare_bytecode(
		t,
		"mov rax, 0xDEADBEEF\nmov rbx, rax",
		asm_to_bytes("mov rax, 0xDEADBEEF\nmov rbx, rax"),
		proc() {
			mov_r64_imm64(Register64.RAX, 0xDEADBEEF)
			mov_r64_r64(Register64.RBX, Register64.RAX)
		},
	)

	// Memory to register to memory
	compare_bytecode(
		t,
		"mov r10, [0x1234]\nmov [0x5678], r10",
		asm_to_bytes("mov r10, qword ptr [rip+0x1234]\nmov qword ptr [rip+0x5678], r10"),
		proc() {
			mov_r64_m64(Register64.R10, 0x1234)
			mov_m64_r64(0x5678, Register64.R10)
		},
	)

	// Extended registers interactions
	compare_bytecode(
		t,
		"mov r8, 0x42\nmov r9, r8\nmov [0xABCD], r9",
		asm_to_bytes("mov r8, 0x42\nmov r9, r8\nmov qword ptr [rip+0xABCD], r9"),
		proc() {
			mov_r64_imm64(Register64.R8, 0x42)
			mov_r64_r64(Register64.R9, Register64.R8)
			mov_m64_r64(0xABCD, Register64.R9)
		},
	)
}

@(test)
test_mov_combinations_advanced :: proc(t: ^testing.T) {
	// Test complex instruction sequences

	// Various immediate encodings
	compare_bytecode(
		t,
		"mov rax, 0x7FFFFFFF\nmov rbx, 0x80000000\nmov rcx, 0xFFFFFFFF",
		asm_to_bytes("mov rax, 0x7FFFFFFF\nmov rbx, 0x80000000\nmov rcx, 0xFFFFFFFF"),
		proc() {
			mov_r64_imm64(Register64.RAX, 0x7FFFFFFF) // Fits in 32-bit positive
			mov_r64_imm64(Register64.RBX, 0x80000000) // 32-bit sign boundary
			mov_r64_imm64(Register64.RCX, 0xFFFFFFFF) // All 32-bit bits set
		},
	)

	// Memory and register operations
	compare_bytecode(
		t,
		"mov r8, 0x12345678\nmov [0x1000], r8\nmov rax, [0x1000]\nmov rbx, rax",
		asm_to_bytes(
			"mov r8, 0x12345678\nmov qword ptr [rip+0x1000], r8\nmov rax, qword ptr [rip+0x1000]\nmov rbx, rax",
		),
		proc() {
			mov_r64_imm64(Register64.R8, 0x12345678)
			mov_m64_r64(0x1000, Register64.R8)
			mov_r64_m64(Register64.RAX, 0x1000)
			mov_r64_r64(Register64.RBX, Register64.RAX)
		},
	)

	// Special registers in combinations
	compare_bytecode(
		t,
		"mov r12, 0xABCDEF\nmov rsp, r12\nmov [0x2000], rsp\nmov rbp, [0x2000]",
		asm_to_bytes(
			"mov r12, 0xABCDEF\nmov rsp, r12\nmov qword ptr [rip+0x2000], rsp\nmov rbp, qword ptr [rip+0x2000]",
		),
		proc() {
			mov_r64_imm64(Register64.R12, 0xABCDEF) // Extended register
			mov_r64_r64(Register64.RSP, Register64.R12) // Target RSP (special)
			mov_m64_r64(0x2000, Register64.RSP) // Source RSP (special)
			mov_r64_m64(Register64.RBP, 0x2000) // Target RBP (special)
		},
	)
}
